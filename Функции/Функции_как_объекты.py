# ---------------------------------------------- Функции как объекты ---------------------------------------------------
# -------------------------------
# Функции как объекты:
writeln = print  # как в языке Pascal

writeln('Hello world!')
writeln('Python')


# Hello world!
# Python


# ------------
def start():
    # тело функции start
    pass


def stop():
    # тело функции stop
    pass


def pause():
    # тело функции pause
    pass


command = input()  # считываем название команды
if command == 'start':
    start()
elif command == 'stop':
    stop()
elif command == 'pause':
    pause()


# Более гибкий вариант:
def start():
    # тело функции start
    pass


def stop():
    # тело функции stop
    pass


def pause():
    # тело функции pause
    pass


commands = {'start': start, 'stop': stop, 'pause': pause}  # словарь соответствия команда → функция
command = input()  # считываем название команды
commands[command]()  # вызываем нужную функцию через словарь по ключу


# -------------------------------
# Функции в качестве аргументов других функций:

def plot(f, a, b):  # Функция высшего порядка
    return f, a, b


def square_add_one(x):
    return x * x + 1


def cube_add_square(x):
    return x ** 3 + x ** 2


print(plot(square_add_one, 1, 10))  # Функция высшего порядка принимает как аргумент другую функцию.
print(plot(cube_add_square, -10, 10))  # Функция высшего порядка принимает как аргумент другую функцию.

# -------------------------------
# Встроенные функции, принимающие функции в качестве аргументов:

# Функция, определяющая условия сравнения элементов, называется компаратор (compare – сравнивать).

# Встроенные функции min(), max(), sorted() – функции высшего порядка, так как принимают в качестве аргумента функцию
# сравнения элементов.

numbers = [10, -7, 8, -100, -50, 32, 87, 117, -210]

print(max(numbers, key=abs))  # указываем функцию abs в качестве компаратора
print(min(numbers, key=abs))  # указываем функцию abs в качестве компаратора
print(sorted(numbers, key=abs))  # указываем функцию abs в качестве компаратора
# -210                                         # максимальный по модулю элемент
# -7                                           # минимальный по модулю элемент
# [-7, 8, 10, 32, -50, 87, -100, 117, -210]    # сортировка на основании модулей элементов


# ------------
# Пусть в списке points хранятся в виде кортежей координаты точек плоскости в двумерной биполярной системе координат.

# points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]
# При использовании встроенной функции sorted() (или списочного метода sort()) сортировка пройдет по первым значениям
# пар кортежа, а в случае их совпадения – по вторым.

# Таким образом, приведенный ниже код:

points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]

points.sort()  # сортируем список точек на месте

print(points)


# [(-10, 15), (1, -1), (1, 5), (2, -4), (2, 3), (7, 18), (10, 9)]


# ИНАЧЕ:
def compare_by_second(point):
    return point[1]


def compare_by_sum(point):
    return point[0] + point[1]


points = [(1, -1), (2, 3), (-10, 15), (10, 9), (7, 18), (1, 5), (2, -4)]

print(sorted(points, key=compare_by_second))  # сортируем по второму значению кортежа
print(sorted(points, key=compare_by_sum))  # сортируем по сумме кортежа


# [(2, -4), (1, -1), (2, 3), (1, 5), (10, 9), (-10, 15), (7, 18)]
# [(2, -4), (1, -1), (2, 3), (-10, 15), (1, 5), (10, 9), (7, 18)]


# -------------------------------
# Функции в качестве возвращаемых значений других функций:


# Объектная сущность функций позволяет и передавать их в качестве аргументов в другие функции, и возвращать одни
# функции из других. То есть, функции могут быть результатом работы других функций, что позволяет писать генераторы
# функций, возвращающие функции в зависимости от передаваемых им аргументов.


# Функция generator возвращает функцию hello как результат работы:
def generator():
    def hello():
        print('Hello from function!')

    return hello  # обычный ретурн, только вместо переменной, функция.


func = generator()
func()  # Hello from function!


# ------------
def generator_square_polynom(a, b, c):
    def square_polynom(x):
        return a * x ** 2 + b * x + c

    return square_polynom


f = generator_square_polynom(a=1, b=2, c=1)
g = generator_square_polynom(a=2, b=0, c=-3)
h = generator_square_polynom(a=-3, b=-10, c=50)

print(f(1))
print(g(2))
print(h(-1))

# Обратите внимание на то, что внутренняя функция square_polynom() использует параметры внешней функции
# generator_square_polynom(). Такую вложенную функцию называют замыканием.

# Замыкания – вложенные функции, ссылающиеся на переменные, объявленные вне определения этой функции, и не
# являющиеся её параметрами.


# -------------------------------
# Задачи:

numbers = [(10, 10, 10), (30, 45, 56), (81, 80, 39), (1, 2, 3), (12, 45, 67), (-2, -4, 100), (1, 2, 99), (89, 90, 34),
           (10, 20, 30), (50, 40, 50), (34, 78, 65), (-5, 90, -1)]


def func_key_for_sorted(x):
    """Дан список numbers, содержащий кортежи чисел. Напишите программу, которая сортирует и выводит список numbers в
    соответствии с суммой минимального и максимального элемента кортежа"""
    return min(x) + max(x)


print(sorted(numbers, key=func_key_for_sorted))

# ------------
from math import sqrt, pow

points = [(-1, 1), (5, 6), (12, 0), (4, 3), (0, 1), (-3, 2), (0, 0), (-1, 3), (2, 0), (3, 0), (-9, 1), (3, 6), (8, 8)]


def compare_sorted_func(ar):
    """Напишите программу, которая сортирует список points координат точек плоскости в соответствии с расстоянием от
    начала координат (точки(0;0). Программа должна вывести отсортированный список."""
    return sqrt(pow(ar[0], 2) + pow(ar[1], 2))


print(sorted(points, key=compare_sorted_func))

# ------------
numbers = [(10, 10, 10), (30, 45, 56), (81, 39), (1, 2, 3), (12,), (-2, -4, 100), (1, 2, 99), (89, 9, 34),
           (10, 20, 30, -2), (50, 40, 50), (34, 78, 65), (-5, 90, -1, -5), (1, 2, 3, 4, 5, 6), (-9, 8, 4),
           (90, 1, -45, -21)]

"""Дан список numbers, содержащий кортежи чисел. Напишите программу, которая с помощью встроенных функций min() и max() 
выводит те кортежи (каждый на отдельной строке), которые имеют минимальное и максимальное среднее арифметическое 
значение элементов."""

dict_new = {sum(i) // len(i): i for i in numbers}

print(dict_new[min(dict_new)])
print(dict_new[max(dict_new)])

# ------------
athletes = [('Дима', 10, 130, 35), ('Тимур', 11, 135, 39), ('Руслан', 9, 140, 33), ('Рустам', 10, 128, 30),
            ('Амир', 16, 170, 70), ('Рома', 16, 188, 100), ('Матвей', 17, 168, 68), ('Петя', 15, 190, 90)]

"""Список athletes содержит сведения о спортсменах в виде кортежей: (имя, возраст, рост, вес).
Напишите программу сортировки списка спортсменов по указанному полю:
1: по имени;
2: по возрасту;
3: по росту;
4: по весу."""


def sorting_option(num_sort):  # Замыкание
    def inner(value):
        return value[num_sort - 1]

    return inner


result_func = sorting_option(int(input()))
athletes.sort(key=result_func)

for i in athletes:
    print(*i)

# ------------
from math import *
from typing import Any


def mathematical_func(num: int) -> Any:
    """Напишите программу, которая принимает число и название функции, а выводит результат применения функции к
    данному числу.
    Список возможных функций:
    квадрат: функция принимает число и возвращает его квадрат;
    куб: функция принимает число, и возвращает его куб; корень: функция принимает число,
    и возвращает корень квадратный из этого числа;
    модуль: функция принимает число, и возвращает его модуль; синус: функция принимает число (в радианах),
    и возвращает синус этого числа."""

    _options = {
        'квадрат': lambda x: pow(x, 2),
        'куб': lambda x: pow(x, 3),
        'корень': sqrt,
        'модуль': fabs,
        'синус': sin
    }

    def inner(options_key: str) -> Any:
        return _options[options_key](num)

    return inner


if __name__ == '__main__':
    function_instance = mathematical_func(int(input()))
    print(function_instance(input().lower()))

# ------------
from typing import List, Callable


def interesting_sorting2() -> Callable[[list[str]], list[str]]:
    """На вход программе подается строка натуральных чисел. Из элементов строки формируется список чисел.
    Напишите программу сортировки списка чисел в порядке неубывания суммы их цифр. При этом, если у двух чисел
    одинаковая сумма цифр, их следует вывести в порядке неубывания."""

    key_for_sorted = lambda x: (sum(map(int, x)), int(x))

    def inner(array: List[str]) -> List[str]:
        array.sort(key=key_for_sorted)

        return array

    return inner


if __name__ == '__main__':
    input_array_numbers = input().split()
    function_instance = interesting_sorting2()

    print(*function_instance(input_array_numbers))
# ------------
