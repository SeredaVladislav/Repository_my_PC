# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Функция print() ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Необязательные аргументы:

# sep="значение":

print('Туториал', 'по', 'функции', 'print')
# Туториал по функции print

print('Туториал', 'по', 'функции', 'print', sep='\n')
# Туториал
# по
# функции
# print

print('Туториал', 'по', 'функции', 'print()', sep=',')
# Туториал,по,функции,print()

print('Туториал', 'по', 'функции', 'print()', sep='\n\n')
# Туториал
#
# по
#
# функции

print('Туториал', 'по', 'функции', 'print()', sep=',+')
# Туториал,+по,+функции,+print()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# end= - с помощью аргумента end можно определить окончание выражения print:

str1 = 'туториал по'
str2 = 'функции print()'
print(str1)
print(str2)
# туториал по
# функции print()

print(str1, end=' ')
print(str2)
# туториал по функции print()

def value(items):
    for item in items:
        print(item, end=' ')

value([1, 2, 3, 4])
# 1 2 3 4

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# file= - файлоподобный объект (поток). По умолчанию - это sys.stdout. Здесь можно указать файл, в который нужно
# записать или добавить данные из функции print.
# Таким образом вывод функции можно сохранять в файлы форматов .csv или .txt. Рассмотрим это на примере с перебором
# всех элементов списка. Он сохраняется в текстовом файле. В первую очередь файл нужно открыть в режиме append. Далее
# определяется функция, чей вывод будет добавляться внутрь текстового файла.

file = open('print.txt', 'a+')

def value(items):
    for item in items:
        print(item, file=file)
    file.close()  # закройте файл после работы с ним.


value([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
# Когда исполнение будет завершено, появится файл print.txt в текущей папке.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# flush= - определяет, нужно ли принудительно очищать поток. По умолчанию = False:

# Как правило, вывод в файл или консоль буферизируется как минимум до тех пор, пока не будет напечатан символ новой
# строки. Буфер значит, что вывод хранится в определенном регистре до тех пор, пока файл не будет готов к сохранению
# значения или не окажется закрыт.
# Задача flush — убедиться в том что, буферизированный вывод благополучно добрался
# до точки назначения.

import time

print('Пожалуйста, введите ваш электронный адрес: ', end=' ')
print('Пожалуйста, введите ваш электронный адрес: ', end=' ', flush=True)
# запустите код выше, чтобы увидеть разницу.
time.sleep(5)
# Пожалуйста, введите ваш электронный адрес:

# Если запустить написанный выше код, вы заметите, что строка с запросом на ввод не появится до тех пор, пока
# таймер не закончится, а программа не закроется. Но если добавить аргумент flush=True, то строка отобразится
# сразу, но нужно будет подождать 5 секунд, чтобы программа закрылась.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
