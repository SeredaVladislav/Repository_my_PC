#  ------------------------------------------- Области видимости -------------------------------------------------------
#  ------------------------------------------- Локальная область видимости ---------------------------------------------
def local():
    x = 5  # локальная переменная
    print(x)


x = 10
local()
print(x)


#  ------------------------------------------- Глобальная область видимости --------------------------------------------
def local():
    print(x)  # так как row нет в локальной области видимости, мы берем её из глобальной области


x = 10
local()
print(x)

x = 3  # переменная из глобальной области видимости


def func():
    global x  # объявляем, что переменная является глобальной через оператор global
    print(x)  # для этой переменной row берется переменная из глобальной области (row = 3)
    x = 5  # переменная локальная
    x += 5  # арифметическое действие с локальной переменной
    return x  # возврат результата работы с локальными переменными


func()  # вызов функции с глобальной переменной
print(x)  # печать возвращаемого значения row


#  ------------------------------------------- Нелокальная область видимости -------------------------------------------
def get_my_func():
    def hello_world():  # вложенная функция
        print("Hello")  # тело вложенной функции

    return hello_world  # присвоение результата работы вложенной функции в основную функцию


hello_world_func = get_my_func()  # получаем результат основной функции с присвоением её в новую
print(type(hello_world_func))  # <class 'function'>
hello_world_func()  # вывод результата работы функции


def get_mul_func(m):
    nonlocal_m = m  # присвоение переменной аргумента основной функции (нелокальная переменная (nonlocal_m)) (замыкание)

    def local_mul(n):  # вложенная функция со своим аргументом
        return n * nonlocal_m  # Возврат в неё арифметической операции с перем. Основной функции и аргументом вложенной

    return local_mul  # возврат вложенной функции в основную


two_mul = get_mul_func(2)  # возвращаем основную функцию, с аргументом m=2
print(two_mul(5))  # 5 * 2, в функцию присваиваем аргумент 5 (def local_mul(digit))


#  ------------------------------------------- *args и **kwargs --------------------------------------------------------

def func(a, b, c):
    print('a =', a)
    print('b =', b)
    print('c =', c)


func(1, 2, 3)  # вызов функции по позиционным аргументам

func(3, 2, 1)  # вызов функции по позиционным аргументам

func(a=1, b=2, c=3)  # вызов функции по именованным аргументам

func(c=3, b=2, a=1)  # вызов функции по именованным аргументам

# # Правильно
# func(a, b, c=3)
#
# # Неправильно
# func(a=1, b, c)


a = [1, 2, 3]
b = [a, 4, 5, 6]  # хранит список в списке
print(b)
# [[1, 2, 3], 4, 5, 6]

a = [1, 2, 3]
b = [*a, 4, 5, 6]  # оператор * позволяет распаковать переменную, даже внутри другой переменной
print(b)
# [1, 2, 3, 4, 5, 6]
print(a)
# [1, 2, 3]
print(*a)  # распаковывает список в значения и выводит в консоль # 1 2 3


def my_func(*args, **kwargs):
    print(type(args))  # тип данных кортеж <tuple>
    print(type(kwargs))  # тип данных словарь <dict>


my_func()


def adder(*nums):  # аргумент нескольких неименованных аргументов
    test = sum(nums)  # в переменную считаем сумму будущих аргументов, через функцию sum()
    return test


print(adder())  # ввод неименованных аргументов
print(adder(1))  # ввод неименованных аргументов
print(adder(1, 2))  # ввод неименованных аргументов
print(adder(1, 2, 3))  # ввод неименованных аргументов


def multiplication(*args):
    num = 1  # в переменную считаем сумму будущих аргументов
    for i in args:
        num = num * i

    return num


print(multiplication(1, 2))  # ввод неименованных аргументов
print(multiplication(1, 2, 3))  # ввод неименованных аргументов
print(multiplication(1, 2, 3, 4))  # ввод неименованных аргументов
print(multiplication(1, 2, 3, 4, 5))  # ввод неименованных аргументов


#  ---------------------------- Изменяемые типы данных как аргументы по умолчанию --------------------------------------

def incorrect_func(name_arg=[]):  # функция с аргументом в виде пустого списка (изменяемый тип данных)
    print("Аргумент до изменения", name_arg)  # выводим пустой список
    name_arg.append(1)  # добавляем значение в аргумент списка
    print("Аргумент после изменения", name_arg)  # выводим результат


incorrect_func()  # первый вызов функции = всё как обычно
print('-----')
incorrect_func()  # второй вызов, в функции уже находится добавленное значение из предыдущего вызова (что не обычно),


# Потому что, при работе с изменяемыми типами данных в аргументах к функциям, при повторном вызове функции,
# интерпретатор обращается по одному и тому же адресу списка в памяти. Поэтому переопределение аргумента в None, т.е.,
# в неизменяемый тип данных, помогает решить эту проблему


def correct_func(name_arg=None):  # функция с аргументом со значением None (неизменяемый тип данных)
    if name_arg is None:  # и условие
        name_arg = []  # пустой список
    print("Аргумент до изменения", name_arg)  # вывод пустого списка
    name_arg.append(1)  # добавление в список значения 1
    print("Аргумент после изменения", name_arg)  # вывод списка с добавленным элементом


correct_func()  # верный вывод
print('-----')
correct_func()  # тот же вывод
print('-----')
correct_func([123])  # список с новым добавленным значением (итого 123 и 123, 1)
print('-----')
correct_func(name_arg=[123])  # то же что и предыдущий вывод, но с указанием именованного аргумента


#  ---------------------------------------- Рекурсивные функции --------------------------------------------------------

def rec(n):  # функция с 1 аргументом
    if n == 1:  # условие терминального случая рекурсии (digit == 1)
        return 1  # возврат 1 при выполнении условия
    return n * (rec(n - 1))  # возврат рекурсивного вызова (5*(5(4)) = 120


# 5! == 1x2x3x4x5
# 5! == 120
# 5! == 5x(4!)->4x(3!)->3x(2!)->2x(1!)->1x(1!) - вызов рекурсии
# 5! == (1)x2x3x4x5 = (1!)x2x3x4x5 = (2!)x3x4x5 = (3!)x4x5 = (4!)x5 == 120! - подсчет значения

print(rec(5))  # вывод с введенным аргументом


def fib(n):  # функция с 1 аргументом
    if n == 0:  # условие
        return 0  # возврат условия
    if n == 1:  # условие
        return 1  # возврат условия
    if n == 2:  # условие
        return 1  # возврат условия
    return fib(n - 1) + fib(n - 2)  # вызов рекурсии
    # : 7 число в последовательности Фибоначчи: 7 = (6 и 5), 6 = (5 и 4), 4 = (3 и 2), 3 = (2 и 1) = 1 и 1 (по условию),
    # далее, обратный порядок подсчета: 3(2)+2(1)=4(3)+3(2)=5(5)+4(3)=6(8)+5(5) == 7(13)


print(fib(7))


def rec_sum(n):  # сумма всех чисел от 1 и до digit
    if n == 1:  # терминальный случай
        return 1
    return n + rec_sum(n - 1)  # рекурсивный вызов. 6 + (5+4+3+2+1) = 21


print(rec_sum(6))


def reverse_str(string):
    if len(string) == 0:
        return ''
    return string[-1] + reverse_str(string[:-1])  # последний символ + слово без последнего символа


print(reverse_str('penis'))


def sum_digit(n):
    if n < 10:
        return n
    else:
        return n % 10 + sum_digit(n // 10)  # остаток от деления и целочисленное деление ((3+2)+(1)) = 6


print(sum_digit(123))
