# Недостатки динамических массивов (списков):  # O(index_del) времени (чем больше массив, тем больше времени
# затрачивается)
# Простой список:
ar = [1, 2, 3, 4]  # Все данные хранятся в непрерывной области памяти.

# Односвязный список:  # 0(1) времени, константная.
ar_2 = [1, 2, 3, 4]


# Выделяем еще одну такую же часть памяти, данные не будут идти строго друг за другом.
# При использовании массива, не приходится копировать часть текущего массива, тем самым не занимая память и обращаться,
# добавлять, возможность будет за константное время O(1)

# Структура:
# head = data[next] -> data[next] -> data[next] -> data[next] -> NULL

# Каждый элемент односвязного списка ссылаются друг на друга по порядку.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Добавление в конец односвязного списка:

# До:
# head = data[next] -> tail = data[next] -> NULL


# На 1-й элемент ссылается переменная head
# На 2-й элемент ссылается переменная tail

# Создаем новый объект с временной переменной node = data[next]
# По ссылке tail выбираем этот элемент списка (последний)
# далее ссылку tail переопределяем на новый добавляемый объект.

# Ссылка последнего элемента должна принимать значение NULL
# Переменной tail нужно присвоить значение node, чтобы tail ссылалась на этот последний элемент списка.

# Часто эта операция реализуется методом push_back()

# После:
# head = data[next] -> data[next] -> tail = data[next] -> NULL

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Добавление в начало односвязного списка:

# До:
# head = data[next] -> data[next] -> tail = data[next] -> NULL

# Создаем объект, на который ссылается временная переменная node.
# Далее, нужно чтобы ссылка node вела на объект на который ссылается head

# Далее, head присваиваем значение node, чтобы head ссылался на node.

# Часто эта операция реализуется методом push_front()

# После:
# head = data[next] -> data[next] -> data[next] -> tail = data[next] -> NULL

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Доступ к произвольному объекту:  # O(index_del) временная сложность линейная

# Псевдо-код:
# head.data - доступ к первому элементу
# tail.data - доступ к последнему элементу

# Создаем временный указатель node, для доступа к следующему элементу:
# Ссылке node присвоить адрес следующего объекта: node = node.next,
# а адрес следующего объекта находится в ссылке next переменной head.

# Указатель node переходит к следующему элементу и так по циклу до конца, пока ссылка не примет значение NULL.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Вставка элемента в односвязный список:

# До:
# head = data[next] -> data[next] -> [             ] data[next] -> tail = data[next] -> NULL

# Создаем новый элемент node
# Находим ссылку на левый элемент от места вставки, и правый элемент от места вставки нового.
# Переопределяем ссылки left.next = node и node.next = right

# После:
# head = data[next] -> data[next] -> data[next] -> data[next] -> tail = data[next] -> NULL

# Часто эта операция реализуется методом insert()

# Нахождение левой ссылки на объект занимает O(index_del) линейное
# Добавление нового элемента занимает O(1) константное

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Удаление промежуточных элементов:  O(index_del) линейная временная сложность

# Переопределяем ссылку на элемент от left на right: left.next = right
# Удаляем ненужный объект.

# Часто эта операция реализуется методом erase()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Удаление первого элемента: O(1)

# Указатель head переместить на второй элемент: head = node
# Удалить ненужный элемент

# Часто эта операция реализуется методом pop_front()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Удаление последнего элемента:

# Получение ссылки на предпоследний элемент
# Удалить последний элемент
# Переместить указатель на предпоследний элемент: tail = node
# Поменять ссылку next: node.next = NULL

# Часто эта операция реализуется методом pop_back()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

class Node:
    def __init__(self, data):
        self.data = data  # данные которые хранятся в узле
        self.next = None  # ссылка на узел

    def append(self, val):  # создает новый узел и добавляет его в конец списка
        end = Node(val)
        n = self
        while n.next:
            n = n.next
        n.next = end


II = Node(1)
II.append(2)
II.append(3)
II.append('5')

node = II
print(node.data)
while node.next:
    node = node.next
    print(node.data)
