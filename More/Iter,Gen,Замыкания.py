# ------------------------------------- Функции-генераторы -------------------------------------------------------------
def my_gen(n):  # функция-генератор с одиночным выводом последующего значения
    while not n == 0:  # цикл с условием, пока digit не равно 0
        yield n  # функция yield возвращает digit
        n += 1  # перезапись аргумента


gen = my_gen(10)  # присвоение генератора переменной
print(type(gen))  # проверка типа данных
print(next(gen))  # печать следующего элемента, пока условие цикла в генераторе не сработает на завершение
print(next(gen))
print(next(gen))
print(next(gen))


def my_gen(n):  # функция-генератор с выводом сразу всего списка
    res = []  # пустой список
    while not n == 0:  # цикл с предусловием
        res.append(n)  # добавление в список аргумента функции
        n -= 1  # счетчик
    return res  # возврат функции


print(my_gen(10))  # вывод генератора списка


def fib():
    a, b = 0, 1
    yield a
    yield b

    while True:
        a, b = b, a + b
        yield b


for i in fib():
    if i > 10:
        break
    print(i)

print()


def count(start=1, step=2):
    counter = start
    while True:
        yield counter
        counter += step


for i in count():
    if i > 10:
        break
    print(i)


def repeat_list(list_):
    list_values = list_.copy()  # присваивание переменной копии аргумента
    while True:
        value = list_values.pop(0)  # присваивание переменной списка с удалением 0 элемента
        list_values.append(value)  # добавление в конец списка 0 элемента
        yield value


for i in repeat_list([1, 2, 3]):  # бесконечный цикл
    print(i)


def gen():  # генератор бесконечных значений
    num = 0
    while True:
        num += 1
        yield num


for i in gen():
    print(i)
    if i >= 5:
        break

# ---------------------------------------------- Итераторы -------------------------------------------------------------

iter(str)  # TypeError: 'type' object is not iterable
iter([1, 2, 3])  # <list_iterator at 0x7fb593ca1940> # итерируемый объект

next()  # функция позволяет получить следующий элемент от итератора

str_ = "my tst"
str_iter = iter(str_)  # функция итератор

print(type(str_))  # строка
print(type(str_iter))  # итератор строк
print(next(str_iter))  # m
print(next(str_iter))  # y
print(next(str_iter))  # ''
print(next(str_iter))  # t
print(next(str_iter))  # count
print(next(str_iter))  # t
print(next(str_iter))  # error StopIteration

lists = [i for i in range(1, 25)]  # генератор списка, с присвоением к переменной
print(lists)


# ---------------------------------------------- Функции высшего порядка -----------------------------------------------
def twice_func(inside_func):  # Функция 1
    """Функция, выполняющая дважды функцию принятую в качестве аргумента"""
    inside_func()
    inside_func()


def hello():  # Функция 2
    print("Hell")  # значение, которое выводит функция 1


twice_func(hello)  # функция 2 в качестве аргумента присваивается функции 1


def twice_func(inside_func):  # Функция 1
    """Функция, выполняющая дважды функцию принятую в качестве аргумента"""
    inside_func()
    inside_func()


@twice_func  # другой способ присвоить функцию 2 в качестве аргумента функции 1
def hello():  # Функция 2
    print("Hell")  # значение, которое выводит функция 1


# ---------------------------------------------- Замыкание функций -----------------------------------------------------

def make_adder(x):  # функция 1
    def adder(n):  # функция 2
        return x ** n  # захват переменной "row" из nonlocal области

    return adder  # возвращение функции 2 в качестве результата


add_2 = make_adder(2)  # присваивание к функции 1 аргумента к переменной
print(add_2(10))  # печать переменной с указанием аргумента к функции 2
print(add_2(100))  # печать переменной с указанием аргумента к функции 2


#  ------------------------------------------ Генераторы списка --------------------------------------------------------

#  Функция map()--------------------------------------------------------------------------------------------------------
list_now_2 = ['1', '2', '3', '4']  # список из строк
list_map = list(map(int, list_now_2))  # генератор с помощью функции map()
print(list_map)  # вывод результата

list_now = [i ** 2 for i in range(1, 6)]  # генератор списка
print(list_now)  # вывод результата генерации

list_gen = [int(i) for i in list_now_2]  # генератор с преобразованием из строки в список значений
print(list_gen)  # вывод результата

s = [1, 2, 3]
d = iter(s)  # итератор с помощью функции iter()
print(next(d))  # вызов каждого последующего элемента
print(next(d))  # вызов каждого последующего элемента
print(next(d))  # вызов каждого последующего элемента

list_now = (i ** 2 for i in range(1, 6))  # выражение генератор (поддерживает только один обход элементов)
print(next(list_now))  # вызов каждого последующего элемента из генератора
print(next(list_now))  # вызов каждого последующего элемента из генератора
print(next(list_now))  # вызов каждого последующего элемента из генератора


#  Основная задача генератора, это перебор больших массивов данных, так как генератор не хранит в себе эти значения, а
#  создает их "налету"


#  yield ---------------------------------------------------------------------------------------------------------------

def cube_num(nums: list):  # функция
    for i in nums:  # цикл с перебором элементов из аргумента функции
        yield i ** 3  # yield возвращает генератор значений (с арифметическим действием n_string ** 3)


a_cube = cube_num([1, 2, 3, 4, 5])  # сохранение генератора в переменную a_cube

print(next(a_cube))  # вывод значений по очередности
print(next(a_cube))  # вывод значений по очередности
print(next(a_cube))  # вывод значений по очередности


# Функция генератор:
def func_gen():
    num = 0
    while True:
        num += 1
        yield num


a = func_gen()
print(next(a))
print(next(a))
print(next(a))


#  ------------------------------------------ Замыкание функции --------------------------------------------------------
def main_func(value):  # Основная функция
    name = value  # Нелокальная переменная

    def inner_func():  # Вложенная функция
        print('hello!', name)  # Вывод в консоль строки + Нелокальная переменная

    return inner_func  # Возврат результата Вложенной функции в Основную


a = main_func('misha')  # Присвоение Основной функции переменной a
b = main_func('Sveta')  # Присвоение Основной функции переменной b
a()  # Вывод результата
b()  # Вывод результата


# Другой вариант замыкания Функции:
def adder(value):  # Основная функция с аргументом
    def inner(a):  # Вложенная функция с аргументом
        return value + a  # Возврат результата Вложенной функции в неё же

    return inner  # Возврат результата Вложенной функции в Основную


summa = adder(10)  # Присвоение Основной функции переменной summa со значением 10 в аргумент value

print(summa(15))  # Вывод результата с аргументом 15 в аргументе a


# Итог аргументу value присвоено значение 10, а аргументу a 15, результат 25


def counter():  # Основная функция
    count = 0  # Нелокальная переменная

    def inner():  # Вложенная функция
        nonlocal count  # Ссылка на Нелокальную переменную count
        count += 1  # Счетчик
        return count  # Возврат результата в Функцию inner

    return inner  # Возврат результата Функции inner в Функцию num к переменной count


a = counter()  # Присвоение Основной функции переменной a
print(a())  # Вывод результата: 1
print(a())  # Вывод результата: 2
print(a())  # Вывод результата: 3
print(a())  # Вывод результата: 4


# ==============================================

# Сведение в сумму введенных значений, разных типов данных

def func(*args):
    g = 0
    g1 = []
    for i in args:
        if isinstance(i, int):
            g += i
        if isinstance(i, str):
            g1.append(i)
    return "{[temp_var, *g1]}"


print(func(4, "_", 1, 222, 3, 6, 6, 6, 5))

# ==============================================

my_tuple = (4, "_", 1, 222, 3, 6, 6, 6, 5)

numeric_sum = sum(x for x in my_tuple if isinstance(x, (int, float)))
string_value = [x for x in my_tuple if isinstance(x, str)][0]  # Получение строки из кортежа

result = [numeric_sum, string_value]
print(result)

# ==============================================