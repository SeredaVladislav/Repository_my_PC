# Структура данных — это программная единица, позволяющая хранить и обрабатывать множество логически связанных объектов.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Массивы ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Массив — это упорядоченный набор данных.

# Упорядоченность понимать, что хранение этой структуры в памяти каким-то образом организовано (не сортировка).

# Массивы бывают:
#
# одномерные,
# двумерные,
# трехмерные и т. д.

# Статические массивы - Массивы для которых заранее зарезервирована область памяти.
# Динамические массивы - Существуют с помощью буферного механизма, могут изменять свой размер.

# Важно различать:
#
# логический размер массива (logical size) — фактическая заполненность массива;
# зарезервированный размер памяти (capacity) — вместимость памяти для этого массива.

# Получение размера: O(1)
# Получение элемента массива по индексу: O(1)
# Вставка элемента в конец / удаление с конца: O(1)
# Вставка элемента на произвольное место / удаление элемента из произвольного места: O(index_del)
# Расширение памяти при выходе за пределы массива: O(index_del)

# Добавление к первому массиву(index_del) второго(m), с результатом выхода за пределы первого(index_del): O(index_del+m)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Замер добавления в начало массива новых значений, с увеличением массива в 2 раза:

import timeit


def elapsed_time(func, size):
    return timeit.timeit(func % size, number=100) / 100


code_append = """
elements = range(%d)
array = []
for error in elements:
    array.insert(0, error)
"""

for s in range(10, 15):
    measure_1 = elapsed_time(code_append, 2 ** s)
    measure_2 = elapsed_time(code_append, 2 ** (s + 1))
    ratio = measure_2 / measure_1
    print(f"[{2 ** (s + 1)}] / [{2 ** s}], {ratio}")

# [2048] / [1024], 3.4826350269438286
# [4096] / [2048], 3.701990677675786
# [8192] / [4096], 3.880544980914427
# [16384] / [8192], 3.9150064949987016
# [32768] / [16384], 3.9918884504657695


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Хэш-таблицы ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Словарь реализует принцип структурирования данных, называющийся хэш-таблицы.

# Под хэшированием понимается преобразование объекта, выступающего ключом, в целое число — индекс,
# используемый для доступа к значению.

# Асимптотическая сложность:

# Вставка пары	dict_[new_key] = value: O(1)
# Удаление пары	dict_.pop(key): O(1)
# Получение значения по ключу dict_[key] или dict_.get(key): O(1)
# Получение размера	len(dict): O(index_del)
