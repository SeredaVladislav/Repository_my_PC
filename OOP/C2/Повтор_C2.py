# --------------------------------------------------- Функции ----------------------------------------------------------
# Различия кода с без использования функции и с использованием:

# Без использования:

streaming = ['netflix', 'hulu', 'disney+', 'appletv+']  # список из 4-х элементов
platform_1 = 'netflix'  # 1-я константа
platform_2 = 'hulu'  # 2-я константа

for i in streaming:  # в цикле перебираем значения списка
    if i == platform_1:  # условие, если элемент списка равен, 1-й константе, то выводим в консоль
        print(f"Платформа {platform_1} найдена!")

for i in streaming:  # в цикле перебираем значения списка
    if i == platform_2:  # условие, если элемент списка равен, 2-й константе, то выводим в консоль
        print(f"Платформа {platform_2} найдена!")


# ---------------------------------------------------------

# С использованием:

def search(online_movie, platform):  # Функция с 2-мя атрибутами
    for i in online_movie:  # в цикле перебираем значения списка
        if i == platform:  # условие, если элемент списка равен 2-му введенному аргументу, то True
            return True
    return False  # иначе, False


if __name__ == "__main__":  # запуск из этого файла
    streaming = ['netflix', 'hulu', 'disney+', 'appletv+']  # список из 4-х элементов
    platform_1 = 'netflix'  # 1-я константа
    platform_2 = 'hulu'  # 2-я константа

    print(f"Платформа {platform_1} в списке?: {search(streaming, platform_1)}")
    # вывод используя вместо аргументов общий список и 1-ю константу
    print(f"Платформа {platform_2} в списке?: {search(streaming, platform_2)}")
    # вывод используя вместо аргументов общий список и 2-ю константу

# --------------------------------------------------- Объекты и классы -------------------------------------------------

# Код создания человека:
# Код без использования Классов:

# 1 человек:
if __name__ == "__main__":
    person1_name = "Max"
    person1_age = 19
    person1_sex = 'M'
    person1_height = 180
    person1_weight = 75

    # 2 человек:
    person2_name = "July"
    person2_age = 17
    person2_sex = 'W'
    person2_height = 170
    person2_weight = 60

    print(f"person 1: {person1_name}")
    print(f"person 2: {person2_name}")

# В этом примере, необходимо каждый раз записывать параметры человека с нуля, и вносить его данные.

print()


# -----------------------------------------
# Код с использованием Класса:

class Person:  # Создается конструктор, в виде Класса Person с шаблонами атрибутов
    def __init__(self, name, age, sex, height, weight) -> None:
        self.name = name
        self.age = age
        self.sex = sex
        self.height = height
        self.weight = weight


if __name__ == "__main__":  # строка, ответственная за запуск кода из текущего файла, во избежание ошибок с импортом

    # Добавление информации о новом человеке, посредством создания экземпляра
    # Класса Person с введением новых атрибутов:
    # Нет необходимости вводить повторно названия переменных, а использовать шаблоны атрибутов Класса.

    person1 = Person("Max", 19, 'M', 180, 75)
    person2 = Person("July", 17, 'W', 170, 60)

    print(f"person 1: {person1.name}")
    print(f"person 2: {person2.name}")


# ---------------------------------------------------- Наследование ----------------------------------------------------

class Object:
    def __init__(self, name) -> None:
        # Поле right_name будет представлено в объектах этого класса
        # и в объектах всех классов наследников
        self.name = name

    # тоже относится и к методу getName(),
    # который будучи однажды реализован не нужно будет уже повторять в дочерних классах
    def getName(self):
        return self.name


# -----------------------------------------

# В Классе PhysicalObject добавим свойства вес и размер:
class PhysicalObject(Object):
    def __init__(self, name, weight, size) -> None:
        super().__init__(name)
        self.weight = weight
        self.size = size

    def getWeight(self):
        return self.weight

    def getSize(self):
        return self.size


# -----------------------------------------

# Классы LivingObject и NonLivingObject объектов повторяют все поля и методы класса PhysicalObject(автоматически)
# и используются, чтобы разделить иерархию на две ветви.

# От NonLivingObject можно будет ввести иерархию в камни, металлы, газы и т.д
class NonLivingObject(PhysicalObject):
    def __init__(self, name, weight, size) -> None:
        super().__init__(name, weight, size)


# А, от LivingObject — в Растения, Животные, Насекомые, Грибы и т.д.
class LivingObject(PhysicalObject):
    def __init__(self, name, weight, size) -> None:
        super().__init__(name, weight, size)  # super().__init__(right_name) конструируем класс и берем свойства right_name из
        # родительского, а остальное пишем новое.


# -----------------------------------------

class A:
    def some_method(self):
        print('some_method A')


class B(A):
    def some_method(self):
        # вызываем метод родительского класса
        super().some_method()
        # Добавляем свое поведение
        print('some_method B')


x = B()
x.some_method()


# some_method A
# some_method B

# ---------------------------------------------------- Инкапсуляция ----------------------------------------------------


class Person:
    def __init__(self, name, age, sex, height, weight) -> None:
        self.name = name
        self.age = age
        self.sex = sex
        self.height = height
        self.weight = weight


# класс Family оперирует не объектами базовых типов,
# а объектами более сложного класса Person
class Family:
    def __init__(self, family_name) -> None:
        self.members = []  # поле пустого списка
        self.familyName = family_name  # поле с названием семьи

    def add_member(self, _classperson):  # метод
        self.members.append(_classperson)  # добавляем в список введенные в аргумент данные


if __name__ == "__main__":
    family = Family('Petrov')  # экземпляр класса Family
    family.add_member(Person('Petr', 22, 'M', 182, 76))  # в метод add_member добавляем данные для класса Person
    print(family.familyName)  # выведет 'Petrov'
    for person in family.members:  # перебираем всех членов семьи
        print(person.right_name, person.age, person.sex, person.height, person.weight)


# ---------------------------------------- Работа над реализацией «жизненной» задачи. Метод Аббота ---------------------

class Washable:
    def __init__(self) -> None:
        self.dirtlevel = 0

    def setDirtLevel(self, level):
        self.dirtlevel = level

    def getDirtLevel(self):
        return self.dirtlevel


class Washer:
    def __init__(self) -> None:
        pass

    def wash(self, washable):
        if washable.getDirtLevel() > 0:
            return "Мама моет Машу!"
        else:
            return "Мама не моет Машу! Она чистая!"


if __name__ == "__main__":
    masha = Washable()
    masha.setDirtLevel(1)

    mom = Washer()
    print(mom.wash(masha))

# ----------------------------------------------------------------------------------------------------------------------

# Как измеряется качество архитектуры ?

# Качество архитектуры обычно измеряется по трём критериям:

# эффективность
# гибкость
# масштабируемость
# ------------------------------------------------- Гибкость -----------------------------------------------------------

import math  # импорт математической библиотеки

if __name__ == "__main__":  # Условный блок, указывающий, что код следующий за ним, будет выполняться только тут!
    a = int(input())  # Ввод коэффициентов квадратного уравнения
    b = int(input())  # Ввод коэффициентов квадратного уравнения
    c = int(input())  # Ввод коэффициентов квадратного уравнения

    d = b * b - 4 * a * c  # Формула вычисления кол-ва корней (дискриминанта)
    if d > 0:  # если результат больше 0, то будет 2 корня
        x1 = (-b + math.sqrt(d)) / (2 * a)  # формула подсчета результата, если имеется 2 корня!
        x2 = (-b - math.sqrt(d)) / (2 * a)

        print(f'x1 = {x1} x2 = {x2}')
    elif d < 0:  # если результат меньше 0, то корней нет
        print('Нет корней!')
    else:  # иначе корень будет 1.
        x = -b / (2 * a)  # формула подсчета, если только 1 корень!
        print(f'x = {x}')

import math  # импорт математической библиотеки


def solveQuadraticEquation(a, b, c):  # функция с принимающая 3 аргумента
    result = []  # список в переменной
    d = b * b - 4 * a * c  # Формула вычисления кол-ва корней (дискриминанта)
    if d > 0:  # если результат больше 0, то будет 2 корня
        x1 = (-b + math.sqrt(d)) / (2 * a)  # формула подсчета результата, если имеется 2 корня!
        x2 = (-b - math.sqrt(d)) / (2 * a)  # формула подсчета результата, если имеется 2 корня!
        result = [x1, x2]  # добавление результата 2 корней в переменную
    elif d < 0:  # если результат меньше 0, то корней нет
        pass  # ничего
    else:  # иначе корень будет 1.
        x = -b / (2 * a)  # формула подсчета, если только 1 корень!
        result = [x]  # добавление результата 1 корня в переменную

    return result  # возврат переменной


if __name__ == "__main__":  # Условный блок, указывающий, что код следующий за ним, будет выполняться только тут!
    a = int(input())  # Ввод коэффициентов квадратного уравнения
    b = int(input())  # Ввод коэффициентов квадратного уравнения
    c = int(input())  # Ввод коэффициентов квадратного уравнения

    solution = solveQuadraticEquation(a, b, c)  # присваиваем переменной результат работы функции
    print(solution)


# ------------------------------------------------- Декоратор @staticmethod --------------------------------------------


class StaticClass:
    # метод bar не содержит элемента self, поэтому является статическим
    def bar():
        print("Статический метод")


StaticClass.bar()


# -----------------------------------------

class StaticClass:

    @staticmethod  # пометили метод декоратором
    def bar():
        print("Статический метод через декоратор")


StaticClass.bar()  # вызов метода от класса (без создания экземпляра класса)

sm = StaticClass()
sm.bar()  # вызов метода из объекта (стандартный вызов метода, из экземпляра, но того же самого метода)


# -----------------------------------------

# Статические методы надо использовать, когда мы должны выполнить какое-то действие, которое не зависит от
# состояния объекта. Например, прочитать файл или вывести на экран какую-либо информацию. Иногда через статические
# методы удобно хранить константы

class StaticClass:

    @staticmethod
    def GET_BAR():  # вспоминаем, что константа пишется со всеми заглавными буквами (капсом)
        return "Константа"


print(StaticClass.GET_BAR())


# ------------------------------------------------- Декоратор @classmethod ---------------------------------------------

# Декоратор @classmethod используется для реализации и явного обозначения полиморфизма.
# Напомним, полиморфизм — это разное поведение методов класса
# родителя в классах наследниках.

# @classmethod - это декоратор в Python, который используется для создания статических методов.

# Он позволяет создавать методы, которые могут быть вызваны без создания экземпляра класса.

# Мы можем вызвать его напрямую, без создания экземпляра. Это позволяет нам вызывать статические методы из любого
# места в коде, даже если мы не создали экземпляр класса.

class ParentClass:

    # метод, помещённый @classmethod - первый аргумент cls - модель класса
    # имя которого будет выводиться на печать при вызове
    @classmethod
    def method(cls, arg):
        print("%s classmethod. %d" % (cls.__name__, arg))

    # этот метод будет заменяться в дочернем классе
    @classmethod
    def call_original_method(cls):
        cls.method(5)

    # это обычный метод
    def call_class_method(self):
        self.method(10)


class ChildClass(ParentClass):

    # метод, заменяющий метод родительского класса
    @classmethod
    def call_original_method(cls):
        cls.method(6)


# Вызываем методы класса через класс.
ParentClass.method(0)  # ParentClassclassmethod. 0
ParentClass.call_original_method()  # ParentClassclassmethod. 5

ChildClass.method(0)  # ChildClassclassmethod. 0
ChildClass.call_original_method()  # ChildClassclassmethod. 6

# Вызываем методы класса через объект.
my_obj = ParentClass()
my_obj.method(1)  # ParentClassclassmethod. 1
my_obj.call_class_method()  # ParentClassclassmethod. 10


# ------------------------------------------------- Декоратор @property ------------------------------------------------

class SomeClass:
    def __init__(self, someData) -> None:
        # мы сохраняем переданные в конструкторе класса данные в поле internalData
        self.internalData = someData


if __name__ == "__main__":
    someObj = SomeClass(5)
    # как видно мы довольно легко можем получить доступ к внутренним данным класса
    # что, не слишком-то хорошо
    print(someObj.internalData)


# -----------------------------------------

class SomeClass:
    def __init__(self, someData) -> None:
        self.__internalData = someData

    @property
    def data(self):
        return self.__internalData

    @data.setter  # так обозначается сеттер на поле data
    def data(self, value):
        self.__internalData = value


if __name__ == "__main__":
    someObj = SomeClass(5)
    print(someObj.__internalData)  # если мы попытаемся получить доступ к данным напрямую
    # то получим сообщение об ошибке

    print(someObj.data)  # выведет 5

    someObj.data = 10  # всё правильно
    print(someObj.data)  # выведет 10


# -----------------------------------------

# Декоратор @property позволяет организовывать класс так, чтобы скрыть внутреннюю структуру класса
# от посторонних глаз (насколько это возможно) и оставить видимым только нужный API.

# В классе создаются методы, которые выполняют функцию:

# getter’ов — методов, которые получают значение поля

# если нужно, setter’ов — методов, которые устанавливают значения полей, соответствующих тем, что помечены
# декоратором @property.

# класс, который представляет собой значение угла
class Angle:
    def __init__(self, angle=0) -> None:
        self.__angle = angle

    @property
    def angle(self):
        return self.__angle

    @angle.setter
    def angle(self, angle):
        self.__angle = angle

    # свойство, которое возвращает значение угла в радианах
    @property
    def rad(self):
        return (self.__angle / 180.0) * 3.14


if __name__ == "__main__":
    angle = Angle(30)
    # выводим значение угла в угловых и радиальных значениях
    print(f'{angle.angle} : {angle.rad}')


# -----------------------------------------

# Создайте вычисляемое свойство для класса Square.
#
# Сделайте метод по вычислению площади свойством.
# Сделайте сторону квадрата свойством, которое можно установить только через сеттер.
# В сеттере добавьте проверку условия, что сторона должна быть неотрицательной

# Решение:

class Square:
    _side = None

    def __init__(self, side) -> None:
        if side > 0:
            self._side = side

    @property
    def side(self):
        return self._side

    @side.setter
    def side(self, value):
        if value > 0:
            self._side = value


if __name__ == "__main__":
    side = Square(15)
    print(f"Площадь квадрата: {side.side * side.side}")

# -----------------------------------------

import datetime
import csv


class BankAccount:  # Класс BankAccount
    MIN_BALANCE = -10_000  # Атрибут (Устанавливающий минимальное значение баланса счета)

    def __init__(self, owner, account_number, balance=0):  # Конструктор с 3 аргументами
        self.owner = owner  # Аргумент (Владелец счета)
        self.account_number = account_number  # Аргумент (Номер счета)
        self.created_at = datetime.now().date()  # Возвращает текущее время

    # общий метод класса, который создает объект прочитывая соответствующий csv файл
    @classmethod  # Декоратор @classmethod, для определения Метода как статичного.
    def from_csv(cls, filepath):  # Общий метод Класса, создающий объект для считывания файла формата cvs.
        # Формат файла cvs используется для хранения таблиц в текстовом виде
        with open(filepath, "flag") as f:  # Открывает файл с помощью функции open()
            row = csv.reader(f).__next__()  # Читает содержимое файла в переменную row
            owner, account_number = row  # присваивание 2 переменным значения row
        return cls(owner, account_number)  # Возвращает объект Класса cls


if __name__ == "__main__":
    my_account = BankAccount.from_csv("testfile.csv")
    print(my_account._owner, my_account._account_number, my_account._balance)


# -----------------------------------------

# Определяйте операцию сравнения на равенство объектов, когда это имеет смысл, реализуя метод __eq__

class Angle:  # Класс Angle (Угол)

    def __init__(self, angle=0) -> None:
        self.__angle = angle  # приватный атрибут __angle

    def __eq__(self, __o: object) -> bool:  # Метод __eq__ позволяет сравнивать объекты
        return self.__angle == __o.__angle  # Возвращает Булевое значение

    @property  # Декоратор для определения статического Метода
    def angle(self):
        return self.__angle  # возвращение приватного атрибута __angle

    @angle.setter  # Обозначение Сеттера на поле angle
    def angle(self, angle):  # Устанавливает значение угла при вызове
        self.__angle = angle


if __name__ == "__main__":
    a1 = Angle(30)  # Объекты Класса
    a2 = Angle(45)
    a3 = Angle(30)
    print(f'a1 == a2 -> {a1 == a2}')  # Вывод значения bool
    print(f'a1 == a3 -> {a1 == a3}')


# -----------------------------------------

# Другим, похожим на __str__ методом, является метод __repr__. Его используют для того,
# чтобы получить строку создания объекта.

class Angle:  # Класс Angle (Угол)

    def __init__(self, angle=0) -> None:
        self.__angle = angle

    def __str__(self):  # Метод, для форматирования строки описания угла (для вывода в консоль)
        return f"""Angle: value = {self.__angle}"""

    def __repr__(self) -> str:  # Метод, для предоставления объекта в виде строки (например для передачи в другие файлы)
        return f"""Angle (angle = {self.__angle})"""

    @property
    def angle(self):  # Декоратор для определения статического Метода
        return self.__angle

    @angle.setter  # Обозначение Сеттера на поле angle
    def angle(self, angle):  # Устанавливает значение угла при вызове
        self.__angle = angle


if __name__ == "__main__":
    a = Angle(30)  # установление объекта Класса
    print(a)  # вывод значения
    print(repr(a))


# -----------------------------------------

# Одно нижнее подчеркивание — для внутреннего использования. “_” ничего не делает, но говорит внешним
# пользователям класса о том, что это поле или метод для «внутреннего» использования, не рекомендуя их использовать.

# Два нижних подчеркивания — скрытые. “__” (почти) полностью скрывает поле или метод от посторонних глаз.
# Сокрытие данных важная часть OOP, не стоит ей пренебрегать.

# Предоставляйте поля во внешний API при помощи декоратора @property.

# -----------------------------------------

# docstring — краткие описания самих классов, их предназначения и API, которые могут быть вызваны в процессе
# выполнения при помощи автоматического поля __doc__.

class Angle:
    # docstring — краткое описание класса, которое в дальнейшем может быть получено через поле __doc__
    """
        A class used to represent an angle.
        Attributes
        ----------
        angle : int
        rad : int (readonly)

        Methods
        -------
        normalize()
            gets angle value to range from 0 to 360
    """

    def __init__(self, angle=0) -> None:
        self.__angle = angle

    @property
    def angle(self):
        return self.__angle

    @angle.setter
    def angle(self, angle):
        self.__angle = angle

    @property
    def rad(self):
        return (self.__angle / 180.0) * math.pi

    def normalize(self):
        self.__angle = self.__angle % 360


if __name__ == "__main__":
    print(Angle.__doc__)  # вывод на печать описания класса выше

# ------------------------------------------------------ Исключения ----------------------------------------------------

# Исключения – это ошибки, которые возникают не во время компиляции программы, а
# в процессе её исполнения, в случаях, если что-то идёт не так.


# Название исключения	       |                     Когда возникает	                           |   Название в Python
# ----------------------------------------------------------------------------------------------------------------------
# Исключение, возникающее при делении на 0	        При делении на ноль	                              ZeroDivisionError
# ----------------------------------------------------------------------------------------------------------------------
# Ошибка значения	                           При невозможности привести один тип к другому                 ValueError
# ----------------------------------------------------------------------------------------------------------------------
# Файл не найден	            Если попытаться открыть файл для чтения, который не был создан        FileNotFoundError
# ----------------------------------------------------------------------------------------------------------------------
# Недостаточно прав	            Если попытаться открыть файл из корневых каталогов при запуске
#                               программы не от имени администратора                                    PermissionError
# ----------------------------------------------------------------------------------------------------------------------

# Пример отлова исключения:

try:  # Добавляем конструкцию try-except для отлова нашей ошибки
    print("Перед исключением")
    # теперь пользователь сам вводит числа для деления
    a = int(input("a: "))
    b = int(input("b: "))
    c = a / b  # здесь может возникнуть исключение деления на ноль
    print(c)  # печатаем c = a / b, если всё хорошо
except ZeroDivisionError as e:  # Добавляем тип именно той ошибки, которую хотим отловить.
    print(e)  # Выводим информацию об ошибке
    print("После исключения")

print("После исключения")

# ----------------------------------------------------- Finally и else -------------------------------------------------

# try:
#     *ваш код*
# except Ошибка:
#     *Код отлова*
# else:
#     *Код, который выполнится, если в блоке try всё хорошо прошло*
# finally:
#     *Код, который выполнится по-любому*

# -----------------------------------------

try:
    print("Перед исключением")
    a = int(input("a: "))
    b = int(input("b: "))
    c = a / b
    print(f"Код выполнился без ошибки. Результат операции: {c}")  # печатаем c = a / b, если всё хорошо
except ZeroDivisionError as e:
    print("Произошла ошибка в выполнении операции (Деление на 0!)")
else:  # код в блоке else выполняется только в том случае, если код в блоке try выполнился успешно
    # (т.е. не вылетело никакого исключения).
    print("Это сообщение вывелось, после успешного выполнения операции!")
finally:  # код в блоке finally выполнится в любом случае, при выходе из try-except
    print("Это сообщение выводится в любом случае, не важно было исключение или нет!")

print("А, это сообщение вывелось, уже после прохождения части кода с отловом исключения!")

# ---------------------------------------------------- Raise -----------------------------------------------------------

age = int(input("How old are you?"))

if age > 100 or age <= 0:  # Проверка условия на ошибку
    raise ValueError("Тебе не может быть столько лет")  # Вывод ошибки, с комментарием о некорректности возраста

print(f"Тебе {age} лет!")  # Это сообщение выводится, только если ошибки не произошло!

# -----------------------------------------

# Полный функционал исключений:

try:  # Блок опасного кода
    num = int(input("Введите число:\t "))  # \t - табуляция большого пробела
except ValueError as e:  # Блок, если сработал отлов исключений
    print("Вы ввели неправильное число")
else:  # Блок, если ошибки не произошло
    print(f"Вы ввели {num}")
finally:  # Блок, который выводится в любом случае
    print("Мы на выходе")
