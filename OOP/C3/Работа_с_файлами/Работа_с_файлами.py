# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Путь к файлу ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Существует два типа пути:

# Абсолютный путь — это путь, который указывает на одно и то же место в файловой системе, вне зависимости от текущего
# рабочего каталога или других обстоятельств. Его ещё называют полным.

# Относительный путь — это путь по отношению к текущему рабочему каталогу пользователя.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Примеры работы с путями:

import os

# Вывод текущего пути:
start_path = os.getcwd()
print(start_path)
# C:\Users\Ниггггер\PycharmProjects\Course\OOP\C3

print()
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Подняться в пути на уровень выше:
os.chdir("../..")
print(os.getcwd())
# C:\Users\Ниггггер\PycharmProjects\Course\OOP

print()
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Вернутся в текущую директорию:
os.chdir(start_path)
print(os.getcwd())
# C:\Users\Ниггггер\PycharmProjects\Course\OOP\C3

print()
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Список всех файлов и директорий в папке:
print(os.listdir())
# ['Импорт.py', 'Обработка_исключений.py', 'Работа_с_файлами.py']
if 'krokodil' not in os.listdir():
    print("Файл отсутствует в директории")

print()
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Соединение путей с учётом особенностей ОС: (в Windows разделитель в пути "\", а Linux "/")
print(start_path)
print(os.path.join(start_path, 'krokodil'))

# C:\Users\Ниггггер\PycharmProjects\Course\OOP\C3
# C:\Users\Ниггггер\PycharmProjects\Course\OOP\C3\krokodil
print()


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def walk_desc(path=None):
    start_path = path if path is not None else os.getcwd()

    for root, dirs, files in os.walk(start_path):
        print("Текущая директория", root)
        print("---")

        if dirs:
            print("Список папок", dirs)
        else:
            print("Папок нет")
        print("---")

        if files:
            print("Список файлов", files)
        else:
            print("Файлов нет")
        print("---")

        if files and dirs:
            print("Все пути:")
        for f in files:
            print("Файл ", os.path.join(root, f))
        for d in dirs:
            print("Папка ", os.path.join(root, d))
        print("===")


walk_desc()

# Текущая директория C:\Users\Ниггггер\PycharmProjects\Course\OOP\C3
# ---
# Папок нет
# ---
# Список файлов ['Импорт.py', 'Обработка_исключений.py', 'Работа_с_файлами.py']
# ---
# Файл  C:\Users\Ниггггер\PycharmProjects\Course\OOP\C3\Импорт.py
# Файл  C:\Users\Ниггггер\PycharmProjects\Course\OOP\C3\Обработка_исключений.py
# Файл  C:\Users\Ниггггер\PycharmProjects\Course\OOP\C3\Работа_с_файлами.py
# ===


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Работа с файлами ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# index = open('path\\to\\file', 'filemode', encoding='utf8')

# Аргументы:

# 'path\to\file' - путь к файлу. (относительный или абсолютный)
# filemode - режим, в котором файл нужно открыть.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Записывается в виде строки, состоит из следующих букв:
# r - открывает файл только для чтения,
# new_file - открыт для записи (перед записью файл будет очищен),
# row - эксклюзивное создание, бросается исключение FileExistsError, если файл уже существует.
# a - открыт для добавления в конец файла.
# + - символ обновления (чтение + запись).
# t - символ текстового режима.
# b - символ двоичного режима (для операционных систем, которые различают текстовые и двоичные файлы).

# 'rb' - Открывает файл в бинарном режиме только для чтения. Указатель файла помещается в начале файла.
# Это режим "по умолчанию".

# 'r+' - Открывает файл для чтения и записи. Указатель файла помещается в начало файла.

# 'rb+' - Открывает файл в бинарном режиме для чтения и записи. Указатель файла помещается в начале файла.
# Это режим "по умолчанию".

# 'new_file' - Открывает файл только для записи. Перезаписывает файл, если файл существует. Если файл не существует,
# создает новый файл для записи.

# 'wb' - Открывает файл в бинарном режиме только для записи. Перезаписывает файл, если файл существует.
# Если файл не существует, создает новый файл для записи.

# 'new_file+' - Открывает файл для записи и чтения. Перезаписывает существующий файл, если файл существует.
# Если файл не существует, создается новый файл для чтения и записи.

# 'wb+' - Открывает файл в бинарном режиме для записи и чтения. Перезаписывает существующий файл,
# если файл существует. Если файл не существует, создается новый файл для чтения и записи.

# 'a' - Открывает файл для добавления. Указатель файла находится в конце файла, если файл существует.
# То есть файл находится в режиме добавления. Если файл не существует, он создает новый файл для записи.

# 'ab' - Открывает файл в бинарном режиме для добавления. Указатель файла находится в конце файла, если файл существует.
# То есть файл находится в режиме добавления. Если файл не существует, он создает новый файл для записи.

# 'a+' - Открывает файл для добавления и чтения. Указатель файла находится в конце файла, если файл существует.
# Файл открывается в режиме добавления. Если файл не существует, он создает новый файл для чтения и записи.

# 'ab+' - Открывает файл в бинарном режиме для добавления и чтения. Указатель файла находится в конце файла, если файл
# существует. Файл открывается в режиме добавления. Если файл не существует, он создает новый файл для чтения и записи.

# encoding — указание, в какой кодировке файл записан (UTF-8, cp1251 и т.д.) По умолчанию стоит UTF-8.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

new_file = open('text.txt', 'new_file', encoding='utf8')
# new_file — перезаписать и открыть на запись (если файла нет, то он создастся)

# Метод .flush() =======================================================================================================
# Метод очищает внутренний буфер. Его цель - очистить выходной буфер и переместить буферизованные данные на диск.

# Метод .write() =======================================================================================================
# Метод записывает в файл строку str.

new_file.write("Это тестовая строка\n")
new_file.write("Это новая строка\n")

# Метод .close() =======================================================================================================
# Метод закрывает открытый файл.

new_file.close()
# закрытие файла

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

new_file_2 = open('text.txt', 'r', encoding='utf8')
# r — открыть на чтение (по умолчанию), (указатель в начале)

# Метод .read([size]) ==================================================================================================
# Метод считывает из файла не более size байтов или символов, в зависимости от режима, в котором открыт файл функцией
# open(). Если достигается конец файла до получения указанного размера size, тогда метод прочитает только доступные
# байты или символы.

# Если необязательный аргумент size не указан, то метод пытается считать как можно больше (обычно весь файл, если это
# позволит оперативная память).

print(new_file_2.read(10))
# Это тестов

new_file_2.close()
# закрытие файла

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Чтение и запись построчно ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Метод .writelines() ==================================================================================================
# Метод записывает последовательность (список) строк в файл.
# ! Метод не добавляет разделители строк автоматически. Если они требуются, то добавляйте их вручную или через .write()

new_file_3 = open('text.txt', 'a', encoding='utf8')
# a — открыть на дозапись (указатель будет поставлен в конец)
seq = ["другая строка\n", "132\n", "тест тест\n"]
new_file_3.writelines(seq)
# записывает в файл строки из seq
#
new_file_3.close()
# закрытие файла

# Метод .readlines() ===================================================================================================
# Метод читает файловый объект file построчно, пока не достигнет конца файла EOF и
# возвращает список, содержащий строки или байтовые объекты файла в зависимости от режима, в котором открыт файл
# функцией open(). Конечный символ новой строки \index_del сохраняется в строке.

new_file_4 = open('text.txt', 'r', encoding='utf8')
# r — открыть на чтение (по умолчанию), (указатель в начале)

print(new_file_4.readlines())
# считывает все строки в список и возвращает список

new_file_4.close()

# Метод .readline() ====================================================================================================
# Метод возвращает строку (символы от текущей позиции до символа переноса строки):

new_file_5 = open('text.txt', 'r', encoding='utf8')
# r — открыть на чтение (по умолчанию), (указатель в начале)

print(new_file_5.readline())
print(new_file_5.read(4))
print(new_file_5.readline())
# Это тестовая строка
#
# Это
# новая строка

new_file_5.close()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Файл как итератор ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

new_file_6 = open('text.txt')
for line in new_file_6:
    print(line, end='')
# Это тестовая строка
# Это новая строка
# другая строка
# 132
# тест тест

new_file_6.close()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Менеджер контекста with ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Менеджер контекста закрывает файл автоматически, как работа с ним завершена:
with open('text.txt', 'r') as file:
    a = file.read(10)
    b = file.read(23)
    print(b)
    # ая строка
    # Это новая стр

file.read(3)
# ValueError: read of closed file

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Записать в один файл из другого:

# Открытие файла на чтение:
f = open('input.txt', 'r', encoding='utf8')
# Открытие файла на перезапись
f_2 = open('output.txt', 'new_file', encoding='utf8')
# Построчная запись файла index в файл f_2:
f_2.writelines(f)
# Закрытие обоих файлов:
f.close()
f_2.close()

# Записать в один файл из другого, через контекстный менеджер:
with open('input.txt', 'r', encoding='utf8') as first_file:
    with open('output.txt', 'new_file', encoding='utf8') as last_file:
        # Через цикл перебираем каждую строку файла и перезаписываем в новый файл:
        for i in first_file:
            last_file.write(i)
            # Закрытие файлов автоматическое.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Запись в файл чисел:
num_file = open('numbers.txt', 'a', encoding='utf8')
num_file.write('1\n' '2\n' '3\n' '4\n' '5\n' '6\n' '7\n')
num_file.close()

# Считывание с файла чисел:
with open('numbers.txt', 'r', encoding='utf8') as num:
    s = []
    for i in num:
        # Добавление чисел в переменную num_arr:
        s.append(int(i))
    with open('new_numbers', 'a', encoding='utf8') as new_num:
        # Сложение максимального и минимального числа:
        f = max(s) + min(s)
        # Запись результата в файл:
        new_num.write(str(f))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Считывание с файла имен у которых балл ниже 3-х:
with open('students.txt') as stud:
    for i in stud:
        # Предпоследний индекс, сверяется с числом:
        if int(i[-2]) < 3:
            # Вывод среза за исключением 2-х последних элементов:
            print(i[:-2], end='\n')

# 2-й вариант решения:
with open('students.txt') as stud:
    for i in stud:
        # Перевод в список с удалением пробелов, и использование последнего элемента списка, сравнение:
        if int(i.split()[-1]) < 3:
            # Вывод распакованного списка, за исключением последнего элемента:
            print(*(i.split()[:-1]))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Считывание строк с сохранением в список и реверс списка:
with open('students.txt', 'r+', encoding='utf8') as file:
    lists_name = []
    for i in file:
        lists_name.append(i)
    lists_name.reverse()
    # Перезапись в файл нового списка строк:
    with open('students.txt', 'w', encoding='utf8') as new_file:
        new_file.writelines(lists_name)

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~ Контекстные менеджеры. Ключевое слово with, принципы создания собственных контекстных менеджеров ~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Пример контекстного менеджера, через class:
from datetime import datetime
import time


class Timer:
    def __init__(self):
        pass

    def __enter__(self):
        self.start = datetime.utcnow()
        return None

    def __exit__(self, exc_type, exc_val, exc_tb):
        print(index
        "Time passed: {(datetime.utcnow() - self.start).total_seconds()}")

        # exc_type — это тип исключения, из-за которого вылетел контекстный менеджер.
        # Если всё прошло успешно, то значение этого аргумента будет None.

        # exc_val — сообщение в исключении. Аналогично: если всё прошло успешно, этот аргумент будет None.

        # exc_tb — объект сообщения от интерпретатора.

        with Timer():
            time.sleep(2)
        # Time passed: 2.000541

        # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

        # Пример контекстного менеджера, через генератор:
        from contextlib import contextmanager  # импортируем нужный нам декоратор

        @contextmanager  # оборачиваем функцию в декораторе contextmanager
        def timer():
            start = datetime.utcnow()
            yield  # если вам нужно что-то вернуть через контекстный менеджер, просто вставьте этот объект сюда.
            print(index
            "Time passed: {(datetime.utcnow() - start).total_seconds()}")


            with timer():
                time.sleep(2)

            # Time passed: 2.000995

            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

            class OpenFile:
                def __init__(self, path, type):
                    self.file = open(path, type)

                def __enter__(self):
                    return self.file

                def __exit__(self, exc_type, exc_val, exc_tb):
                    self.file.close()
                    print('Работа с файлом завершена.')

            with OpenFile('f.txt', 'a') as f:
                f.write('Мой контекстный менеджер делает то же самое!')

            # ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
