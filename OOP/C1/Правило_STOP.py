# S — Step Back — сделай шаг назад.

# Отойди на некоторое расстояние от того, чем сейчас занят — не спеши переходить к модулю С1, если плохо
# понимаешь остальные. Отдели себя от эмоций, мыслей, действий, которые совершаешь по инерции: в четверг
# модуль открылся, я иду делать. Отступи и соберись с мыслями.
# ----------------------------------------------------------------------------------------------------------------------

# Т — Think — подумай.

# Задай себе несколько вопросов, которые создадут нужный фокус:
# Чего я пытаюсь достичь?
# Каковы мои приоритеты?
# Нужно ли мне поменять направление?
# Каковы последствия моих действий?
# Чего мне не хватает?
# Что является истинной проблемой?
# Чего я действительно хочу?
# Как к этому относятся другие?
# Какие ресурсы я ещё не задействовал?
# ----------------------------------------------------------------------------------------------------------------------

# O — Organize your thoughts — организуй свои мысли.

# Прежде чем продолжать бой, необходимо упорядочить своё сознание. Нужно создать понятный план шагов,
# расставить приоритеты, наметить последовательность действий. Всё это нужно сделать до того, как снова
# вернёшься на поле битвы.
# ----------------------------------------------------------------------------------------------------------------------

# Р — Proceed — продолжай действовать.

# Как только поймешь, что твои мысли прояснились, план действий понятен, эмоции под контролем,
# можно возвращаться к работе. Сражайся в полную силу до тех пор, пока тебе снова не понадобится отдых.
# И тогда можешь снова сказать себе «STOP» на ... (укажи своё время).
# ----------------------------------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------------------------------

# Парадигмы программирования

# В программировании выделяют несколько основных подходов, которые определяют стиль программирования — парадигмы
# программирования (набор идей и понятий).

# Две основных: Императивную и Декларативную.

# Императивная парадигма программирования

# Эта парадигма основана на том, что разработчик (как и тестировщик)
# пишет для компьютера инструкции, которым тот следует.
# К Императивной парадигме относятся, например, Процедурное; Структурное; Аспектно-Ориентированное;
# Объектно-Ориентированное Программирование.


# Императивная парадигма программирования:


# Код, в которой создаётся холст* приложения из библиотеки Tkinter (для графических объектов)

# Canvas(холст) — это достаточно сложный объект библиотеки tkinter. Он помогает располагать геометрические фигуры,
# узоры, вставленные изображения и другие виджеты (например, метки, кнопки, текстовые поля).

from tkinter import *

root = Tk()

c = Canvas(width=200, height=200, bg='white')
c.pack()

c.create_line(10, 10, 190, 50)

c.create_line(100, 180, 100, 60, fill='green',
              width=5, arrow=LAST, dash=(10, 2),
              activefill='lightgreen',
              arrowshape=(10, 20, 10))
root.mainloop()

# Декларативная парадигма программирования:

# Эта парадигма отличается тем, что вы описываете проблему и ожидаемый результат,
# но не создаёте никаких инструкций: отсутствуют переменные, состояние и прочие понятия, которые
# свойственны императивной парадигме.

# К Декларативной парадигме относятся:  Функциональное и Логическое программирование.

# Пример:
# SELECT digit FROM N WHERE digit > 3 AND digit < 100

# Этот код позволяет получить значения поля digit, которые больше 3, но меньше 100.

# ----------------------------------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------------------------------
# ----------------------------------------------------------------------------------------------------------------------

# Принципы программирования:

# YAGNI — You Ain’t Gonna Need It.
# Суть принципа: Реализуйте только поставленные задачи! Не делайте то, что не нужно.

# KISS —  Keep It Simple, Stupid.
# Суть принципа: Люди (включая пользователей продуктов и услуг), как правило, хотят простых вещей, то есть простых
# в освоении и использовании. Избегайте чрезмерного проектирования и усложнения!

# SOLID — Single responsibility principle/Open/closed principle/Liskov substitution
# principle/Interface segregation principle/Dependency inversion principle.
# Суть принципа: Люди (включая пользователей продуктов и услуг), как правило, хотят простых вещей, то есть простых в
# освоении и использовании. Избегайте чрезмерного проектирования и усложнения!

# DRY — Don’t Repeat Yourself.
# Суть принципа: нужно избегать повторений одного и того же кода. Лучше использовать универсальные свойства и функции.


# SOLID (ещё один принцип)

# Single responsibility principle — принцип единственной обязанности (на каждый класс должна быть возложена
# одна единственная обязанность). Это как при распределении задач внутри коллектива. Эффективная работа строится
# тогда, когда каждый выполняет свою определённую задачу.

# Например, вам нужно организовать комплексное тестирование сложного продукта. Можно всё взять на себя,
# а можно грамотно делегировать обязанности и сделать всё быстрее и качественнее.

# Open/closed principle — принцип открытости/закрытости. Код, который вы пишете, должен быть масштабируемым,
# то есть должна быть возможность для его расширения. Но при этом внесение добавлений не должно требовать
# изменений в коде, который уже написан.

# Liskov substitution principle — принцип подстановки Барбары Лисков. Это принцип объектно-ориентированного
# программирования, касающийся классов, интерфейсов, типов и подтипов. Суть его в том, что каждый подтип должен
# дополнять, а не заменять базовый тип.

# Interface segregation principle — принцип разделения интерфейса. Ни один клиент не должен зависеть от
# методов, которые он не использует.

# Dependency inversion principle — принцип инверсии зависимостей.


