# -------------------------------------------- Работа с файлами в Python -----------------------------------------------
# -------------------------------
# ------------

# -------------------------------
# Открытие файла:

# Функция open():
# Она создает файловый объект и связывает его с файлом на диске. Общий формат применения функции open():
# файловая_переменная = open(имя_файла, режим_доступа)

# 1. файловая переменная – имя переменной, которая ссылается на файловый объект;
# 2. имя_файла – строковый литерал, задающий имя файла;
# 3. режим_доступа – строковый литерал, задающий режим доступа (чтение, запись, и т.д.), в котором файл будет открыт.

# ------------
# 'r' Read (чтение):
# Открыть файл только для чтения. Такой файл не может быть изменен.

# 'w' Write (запись):
# Открыть файл для записи. Если файл уже существует, стереть его содержимое.
# Если файл не существует, он будет создан.

# 'a' Append (добавление):
# Открыть файл для записи. Данные будут добавлены в конец файла. Если файл не существует, он будет создан.

# 'r+' Read + Write:
# Открыть файл для чтения и записи. В этом режиме происходит частичная перезапись содержимого файла.

# 'x' Create (создание):
# Создать новый файл. Если файл существует, произойдет ошибка.
# ------------

student_file = open('students.txt', 'r')
# По умолчанию режим доступа (второй аргумент функции open()) определен для чтения (литерал 'r'), поэтому файл
# students.txt можно открыть для чтения так:

student_file = open('students.txt')  # по умолчанию режим доступа для чтения ('r')

# !!! В переменную student_file в примере выше не попадает содержимое файла students.txt. Фактически это ссылка на файл,
# ее еще называют ДЕСКРИПТОР ФАЙЛА.
# ------------

sales_file = open('sales.txt', 'w')
# После исполнения этого кода будет создан файл sales.txt и переменная sales_file будет ссылаться на файловый объект,
# который можно использовать для записи в него данных.

# -------------------------------
# Указание места расположения файла:

customer_file = open('customers.txt', 'r')
# Файл customers.txt программа станет искать в папке C:\Users\Documents\Python.

# Если имя файла не содержит путь, то используется относительный путь, относительно папки, где находится
# исполняемая программа.
# ------------

# Если требуется открыть файл, расположенный в другом месте, нужно указать путь и имя файла в аргументе,
# передаваемом в функцию open().

test_file = open('C:\\Users\\temp\\test.txt', 'w')
# Символ \ является специальным символом в Python и его нужно экранировать (\\), чтобы интерпретатор Python
# рассматривал обратную косую черту как обычный символ.

# Вместо экранирования символов можно использовать сырые строки (raw strings). Для этого следует снабдить строковый
# литерал префиксом в виде буквы r.

test_file = open(r'C:\Users\temp\test.txt', 'w')
# Приведенный выше код создает файл test.txt в папке C:\Users\temp. Префикс r указывает на то, что строковый литерал
# является сырым (неформатированным).

# ------------
path = 'C:\new\text.txt'
print(path)
# C:
# ew	ext.txt
# Поскольку символы \n и \t интерпретируются как перенос строки и табуляция.

# Приведенный ниже код:
path = r'C:\new\text.txt'
print(path)
# C:\new\population.txt

# Чтобы сделать работу с файлами универсальнее, в путях файлов в Windows в Python-программах рекомендуется ставить
# прямой слеш (/):

file1 = open(r'C:/Users/temp/test.txt')  # используем прямой слеш / (абсолютный путь)
file2 = open(r'temp/population.txt')  # используем прямой слеш / (относительный путь)

# -------------------------------
# Кодировка:

# Открыть файл, содержащий только латиницу и цифры, можно так:
file = open('info.txt', 'r')
# При работе с текстом на русском языке нужно указать кодировку, для этого служит параметр encoding:
file = open('info.txt', 'r', encoding='utf-8')

# Чтобы получить кодировку открытого файла, используют файловое свойство encoding:
file1 = open('students.txt', 'w')
file2 = open('customers.txt', 'w', encoding='utf-8')

print(file1.encoding)
print(file2.encoding)

file1.close()
file2.close()
# cp1252
# utf-8

# -------------------------------
# Закрытие файлов:

# После окончания работы с файлом его необходимо закрыть. Для этого есть несколько причин:
# 1. если файл изменялся, это позволит корректно его сохранить;
# 2. если открытый файл потребуется другим программам, ваша программа может его блокировать;
# 3. не стоит держать в памяти лишние, уже не нужные, данные;
# 4. удалить открытый кем-то файл проблематично.

# Для закрытия файла используется файловый метод close():
file = open('info.txt', 'r')  # открываем файл с именем info.txt для чтения
file.close()  # закрываем файл после окончания работы

# Чтобы проверить открыт файл или закрыт можно использовать файловое свойство (атрибут) closed:
file1 = open('students.txt', 'w')
file2 = open('customers.txt', 'w')

file1.close()

print(file1.closed)
print(file2.closed)

file2.close()
# True
# False

# Важно, что при вызове метода мы используем скобки: close(), а при вызове свойства (атрибута)
# скобок нет closed. Методы совершают действия, а свойства возвращают информацию об объекте.

# -------------------------------------------- Чтение содержимого файла ------------------------------------------------

file = open('info.txt', 'w', encoding='utf-8')  # открываем файл для записи

print(file)
# <_io.TextIOWrapper name='info.txt' mode='w' encoding='utf-8'>

# Для чтения содержимого открытого для чтения файла используются три файловых метода:

# 1. read() – читает все содержимое файла;
# 2. readline() – читает одну строку из файла;
# 3. readlines() – читает все содержимое файла и возвращает список строк.

# -------------------------------
# Метод read():

# Метод read() считывает все содержимое из файла и возвращает строку, которая может содержать символы перехода на
# новую строку '\n':

file = open('languages.txt', 'r', encoding='utf-8')

content = file.read()  # 'Python\nJava\nJavascript\nC#\nC\nC++\nPHP\nR\nObjective-C'.
file.close()

# !!!  Метод read() считывает все содержимое файла, включая переносы строк.
# Считывать файл посимвольно можно при помощи метода read(1)

# -------------------------------
# Метод readline():

# Считывает одну строку из файла, до места перехода на новую строку в файле(\n).
# Возврат строки происходит вместе с символом перехода на новую строку - \n
# Если достигнут конец файла - возвращается пустая строка.

file = open('languages.txt', 'r', encoding='utf-8')

language = file.readline()  # 'Python\n'.
file.close()

# ------------
# P.S. Для удаления символов перехода из конца возвращаемой строки, используется метод - str.rstrip().
line = 'Python\n'
line = line.rstrip()
# ------------

# Прочитать содержимое всего файла построчно можно двумя способами:
# 1. С помощью цикла while:
file = open('languages.txt', 'r', encoding='utf-8')
line = file.readline()  # считываем первую строку

while line != '':  # пока не конец файла
    print(line.strip())  # обрабатываем считанную строку
    line = file.readline()  # читаем новую строку
file.close()

# 2. С помощью цикла for (предпочтительный вариант):
file = open('languages.txt', 'r', encoding='utf-8')

for line in file:
    print(line.strip())
file.close()

# -------------------------------
# Метод readlines():

# Считывает все строки из файла.
# Возвращает список из всех считанных строк (одна строка — один элемент списка).
# При этом, каждая строка в списке заканчивается символом переноса строки '\n'.

file = open('languages.txt', 'r', encoding='utf-8')

languages = file.readlines()  # ['Python\n', 'Java\n', 'Javascript\n', 'C#\n', 'C\n', 'C++\n', 'PHP\n', 'R\n',
# 'Objective-C']
file.close()

# P.S. Чтобы удалить символ '\n' можно использовать:

# 1. списочное выражение:
languages = [line.strip() for line in file.readlines()]
# 2. функцию map():
languages = list(map(str.strip, file.readlines()))
# 3. анонимную функцию:
languages = list(map(lambda line: line.strip(), file.readlines()))

# -------------------------------------------------- Примечания --------------------------------------------------------

# Бинарные файлы:
# 't'	Текстовый режим (значение по умолчанию)	Работа с текстовым файлом
# 'b'	Бинарный режим	Работа с бинарными файлами (картинки, звук и т.д.)

file = open('file.dat', 'rb')  # Открывает файл file.dat в режиме чтения как бинарный файл.

# P.S. По умолчанию функция open() использует литерал 'rt', то есть файл открывается для чтения в текстовом  режиме.
# ------------

# Примечание 1. Еще раз обратите внимание на то, что в путях до файла используются прямые слеши /. Можно использовать
# и обратные, но тогда их придется экранировать либо применять модификатор сырой строки r. Кроме того, в unix-подобных
# операционных системах принято использовать именно прямой слеш.
# ------------

# Примечание 2. Существуют специальные символы:
# \n – перемещает позицию печати на одну строку вниз;
# \r – перемещает позицию печати в крайнее левое положение строки.

print('aaaaaa\nbb')
# aaaaaa
# bb

print('aaaaaa\rbb')
# bbaaaa

print(ord('\n'))
print(ord('\r'))


# 10
# 13
# ------------

# Три полезных атрибута (свойства):

# file.closed возвращает истину (True), если файл закрыт, иначе возвращает ложь (False)
# file.mode	возвращает режим доступа, с помощью которого был открыт файл
# file.name	возвращает имя файла
# ------------
# ---------------------------------------------------- Задачи ----------------------------------------------------------

def penultimate_line(name_file: str) -> None:
    """
    На вход программе подается строка с именем текстового файла. Напишите программу, которая выводит на экран его
    предпоследнюю строку.

    :param name_file: Название файла.
    :return: None, принт(Массив строк).
    """
    var_for_file = open(name_file, 'r', encoding='UTF-8')
    result: list[str] = var_for_file.readlines()

    print(result[-2])
    var_for_file.close()


if __name__ == '__main__':
    text_input: str = input()
    penultimate_line(text_input)
# ------------

import random


def random_string():
    """
    Вам доступен текстовый файл population.txt из нескольких строк. Напишите программу, которая выводит на экран случайную
    строку из этого файла.
    :return:
    """
    line_rand = open('population.txt', 'r', encoding='utf-8')
    print(random.choice(line_rand.readlines()))

    line_rand.close()


if __name__ == '__main__':
    random_string()
# ------------

summ = open('population.txt', 'r', encoding='utf-8')
"""Вам доступен текстовый файл population.txt из двух строк, на каждой из них записано целое число. Напишите программу, 
выводящую на экран сумму этих чисел."""
func = lambda x, y: int(x) + int(y)
print(func(*summ.readlines()))
summ.close()
# ------------

summ = open('prices.txt')
"""Вам доступен текстовый файл prices.txt. В файле записано два целых числа, они могут быть разделены символами пробела 
и конца строки. Напишите программу, выводящую на экран сумму этих чисел."""

sor = list(filter(lambda x: x, map(str.strip, summ)))
print(sum(map(int, sor)))
summ.close()
# ------------

import functools

price_file = open('prices.txt')
"""
    Вам доступен текстовый файл prices.txt с информацией о заказе из интернет магазина. В нем каждая строка с помощью 
    символа табуляции (\t) разделена на три колонки:
    1. наименование товара;
    2. количество товара (целое число);
    3. цена (в рублях) товара за 1 шт (целое число).
"""

array_price = map(str.split, price_file.readlines())
array_price = list(functools.reduce(lambda x, y: int(x) * int(y), i[1:]) for i in array_price)

print(sum(array_price))
price_file.close()
# ------------
