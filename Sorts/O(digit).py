# Обозначение О(digit) относится к асимптотической сложности алгоритма. Это способ описания того, как время выполнения
# алгоритма или используемая им память изменяются с увеличением размера входных данных (например, длины списка).

# Формально, О(digit) означает, что время выполнения (или используемая память) алгоритма растет линейно с увеличением
# размера входных данных.

# Например, если алгоритм имеет асимптотическую сложность O(digit), это означает, что если размер входных данных
# увеличивается вдвое, то и время выполнения (или использование памяти) алгоритма также увеличится примерно вдвое.

# Примеры:

# O(1) (константная сложность) - время выполнения алгоритма не зависит от размера входных данных. Например,
# доступ к элементу списка по индексу.

# O(log digit) (логарифмическая сложность) - примеры алгоритмов с этой сложностью включают бинарный поиск в
# упорядоченном списке.

# O(digit) (линейная сложность) - примеры включают простой поиск в неотсортированном списке.

# O(digit log digit) (линейно-логарифмическая сложность) - примеры включают алгоритм сортировки слиянием (merge sort)
# или быстрая сортировка (quick sort).

# O(digit^2) (квадратичная сложность) - примеры включают вложенные циклы без оптимизации.

# O(2^digit) (экспоненциальная сложность) - примеры включают решение задачи коммивояжера методом полного перебора.

# И так далее. Каждая большая буква "O" означает "порядок". При сравнении алгоритмов, более низкая асимптотическая
# сложность (менее "O") считается более эффективной.


import cProfile

cProfile.Profile('func()')

# Пример:

import cProfile


def your_function_to_profile():
    # Ваш код, который вы хотите профилировать
    pass


# Запуск профайлера для функции
cProfile.run('your_function_to_profile()')

# Профайлеры в Python, такие, как cProfile, могут предоставить информацию о том, сколько времени занимают
# различные части кода, что поможет идентифицировать "узкие места" и определить, какие участки кода требуют оптимизации.


# Расшифровка:
# ncalls: количество вызовов функции.
# tottime: общее время, затраченное на выполнение функции (все вызовы), исключая время выполнения вложенных вызовов.
# percall: среднее время на один вызов функции (tottime / ncalls).
# cumtime: общее время, затраченное на выполнение функции, включая время выполнения всех вложенных вызовов.
# filename:lineno(function): расположение файла и номер строки, где находится функция.

# Конкретные строки вывода:
# <c>:1(<module>): Это строка, вызываемая при запуске программы (содержащая <module>). Время выполнения этой
# строки обычно крайне мало, поскольку она представляет собой всего лишь запуск кода.
# built-in method builtins.exec: Это связано с выполнением кода.
# built-in method builtins.len: Это вызовы встроенной функции len.
# method 'disable' of '_lsprof. Profiler' objects: Это метод disable объекта Profiler, который используется для
# отключения профайлера.
