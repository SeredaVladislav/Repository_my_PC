# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Множества set() ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Изменяемый тип данных;
# Не хэшируемый;
# Неупорядоченный тип данных;
# Содержит, только уникальные элементы.
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Свойства множеств set:

# 1. Множества не поддерживают сортировку.
# 2. Множества не поддерживают индексирование элементов, срезы, конкатенацию, умножение на число.
# 3. Двоичные операции, которые смешивают типы set с frozenset, возвращают тип первого операнда.
#    Например: frozenset('ab') | set('bc') возвращает тип frozenset.
# 4. Оба типа set и frozenset поддерживают операции сравнения. Тип set сравниваются с типом frozenset на основе
# их членов. Например:

print(set('abc') == frozenset('abc'))  # True
print(set('abc') in {frozenset('abc')})  # True
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Чтобы создать пустое множество необходимо использовать `set()`, а не `{}`, т.к. пустые фигурные скобки создадут
# пустой [словарь][t-dict].
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Создание пустых множеств:
my_set = set()  # пустое множество
my_frozenset = frozenset()  # пустое множество frozenset

my_set2 = {1, 2, 3, (00, 11, 00), "a", "b", 1.2, }  # множество может содержать int, tuple, str, float
my_set3 = set(range(2, 10, 2))  # {8, 2, 4, 6}
my_set4 = set('ъъъ эээ ююю яяя')  # {'ъ', 'я', 'ю', ' ', 'э'}
my_set5 = set(['ъъъ', 'эээ', 'ююю', 'яяя'])  # {'ююю', 'эээ', 'ъъъ', 'яяя'}

my_set6 = {1, 2, [5, 6], 7}  # множество не может содержать список
my_set7 = {1, 2, {5, 6}, 7}  # множество не может содержать множество
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# # Создание непустых изменяемых множеств set():
s = {'a', 'b', 'c', 'd'}  # {'a', 'b', 'c', 'd'}
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# При преобразовании последовательности в множество удаляются дубликаты элементов:
line = 'abracadabra'
a = set(line)  # {'a', 'r', 'd', 'c', 'b'}

lst = ['a', 'b', 'c', 'd', 'a', 'b', 'c', 'd']
b = set(lst)  # {'a', 'b', 'c', 'd'}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Методы Множества ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Метод .add()
# Добавление элемента в set:
a.add(10)  # {'a', 10, 'r', 'd', 'c', 'b'}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Метод .remove()
# Удаляет элемент из множества с генерацией исключения в случае, если такого элемента нет:
a.remove('r')  # {'a', 10, 'd', 'c', 'b'}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Метод .discard()
# Удаляет элемент из множества без генерации исключения, если элемент отсутствует:
numbers = {1, 2, 3, 4, 5}

numbers.discard(10)
print(numbers)  # {1, 2, 3, 4, 5}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Метод .pop()
# Удаляет и возвращает случайный элемент из множества с генерацией исключения при попытке удаления из пустого множества:

numbers = {1, 2, 3, 4, 5}

num = numbers.pop()  # Удаляет случайный элемент множества, возвращая его.
print('удалённый элемент:', num)  # удалённый элемент: 1
print('после удаления:', numbers)  # после удаления: {2, 3, 4, 5}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Метод .clear()
# Удаляет все элементы из множества:
numbers = {1, 2, 3, 4, 5}

numbers.clear()
print(numbers)  # set()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Функция sorted()
# При необходимости сортировки множества, используется функция sorted(),
# которая возвращает отсортированный массив, а не множество.
numbers = {0, 1, 1, 2, 3, 3, 3, 5, 6, 7, 7}

sorted_numbers = sorted(numbers, reverse=False)
print(sorted_numbers)  # [0, 1, 2, 3, 5, 6, 7]

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Операции над множествами ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1. Объединение;
# 2. Пересечение;
# 3. Разность;
# 4. Симметрическая разность;
# 5. Дополнение.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 1. Объединение: set.union(set) или |
# Объединение множеств – множество, состоящее из элементов, принадлежащих хотя бы одному из объединяемых множеств.
# Возвращает новое множество. Для изменения текущего множества - метод .update() или |=.

X = {1, 2, 3, 4, 5}
Y = {3, 4, 7, 8, 9}
# X | Y = {1, 2, 3, 4, 5, 7, 8, 9}  # Все уникальные общие элементы.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 2. Пересечение: set.intersection(set) или &
# Пересечение множеств – множество, состоящее из элементов, принадлежащих одновременно каждому из пересекающихся
# множеств. Возвращает новое множество. Для изменения текущего множества - метод .intersection_update() или &=.

X2 = {1, 2, 3, 4, 5}
Y2 = {3, 4, 7, 8, 9}
# X2 & Y2 = {3, 4}  # Уникальные, только общие элементы.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 3. Разность: set.difference(set) или -
# Разность множеств – множество, в которое входят только элементы первого множества, не входящие во второе множество.
# Возвращает новое множество. Для изменения текущего множества - метод .difference_update() или -=.

X3 = {1, 2, 3, 4, 5}
Y3 = {3, 4, 7, 8, 9}
# X3 - Y3 = {1, 2, 5}  # Все элементы 1-го множества, за исключением общих.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 4. Симметрическая разность: set.symmetric_difference(set) или ^
# Эквивалент: (X ∪ Y) \ (X ∩ Y)
# Симметрическая разность множеств – множество, включающее все элементы исходных множеств, не принадлежащие
# одновременно обоим исходным множествам.
# Возвращает новое множество. Для изменения текущего множества - метод .symmetric_difference_update() или ^=.

X4 = {1, 2, 3, 4, 5}
Y4 = {3, 4, 7, 8, 9}
# X4 ^ Y4 = {1, 2, 5, 7, 8, 9}  # Все элементы, кроме общих


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# 5. Дополнение:
# Дополнение множества – множество всех элементов, в нем не содержащихся.

# Для операции дополнения множества используется символ ¬.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Примечание:
mylist = [2021, 2020, 2019, 2018, 2017, 2016]
mytuple = (2021, 2020, 2016)
mystr = 'abcd'

myset = {2009, 2010, 2016}

print(myset.union(mystr))  # объединяем со строкой  {2016, 'c', 'b', 'a', 'd', 2009, 2010}
print(myset.intersection(mylist))  # пересекаем со списком  {2016}
print(myset.difference(mytuple))  # находим разность с кортежем  {2009, 2010}

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Операции с несколькими множествами сразу:
myset1 = {1, 2, 3, 4, 5, 6}
myset2 = {2, 3, 4, 5}
myset3 = {5, 6, 7, 8}

union1 = myset1.union(myset2, myset3)
union2 = myset1 | myset2 | myset3

difference1 = myset1.difference(myset2, myset3)
difference2 = myset1 - myset2 - myset3  # порядок выполнения слева-направо

print(union1 == union2)  # True
print(difference1 == difference2)  # True

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Приоритет операторов (сверху вниз):

# -	разность
# &	пересечение
# ^	симметрическая разность
# |	объединение


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Подмножества и надмножества (методы) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Метод .issubset()
# Является ли одно из множеств подмножеством другого.

set1 = {2, 3}
set2 = {1, 2, 3, 4, 5, 6}
print(set1.issubset(set2))  # True
# set1 является подмножеством set2, т.к., set2 содержит все элементы set1.


set1 = {2, 3}
set2 = {1, 2, 3, 4, 5, 6}
print(set1 <= set2)  # True
# Для определения, является ли одно из множеств подмножеством другого, также применяются
# операторы <= (нестрогое подмножество) и < (строгое подмножество).


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Метод .issuperset()
# Является ли одно из множеств надмножеством другого.

set1 = {'a', 'b', 'c', 'd', 'e'}
set2 = {'c', 'e'}
print(set1.issuperset(set2))  # True

# Для определения, является ли одно из множеств надмножеством другого, также применяются
# операторы >= (нестрогое надмножество) и > (строгое надмножество).

set1 = {'a', 'b', 'c', 'd', 'e'}
set2 = {'c', 'e'}

print(set1 >= set2)  # True

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Метод .isdisjoint()
# Отсутствие общих элементов в множествах.

set1 = {1, 2, 3, 4, 5}
set2 = {5, 6, 7}
set3 = {7, 8, 9}

print(set1.isdisjoint(set2))  # False
print(set1.isdisjoint(set3))  # True
print(set2.isdisjoint(set3))  # False

# set1 <= set2, set1.issubset(set2), Возвращает True, если set1 является подмножеством set2
# set1 >= set2, set1.issuperset(set2), Возвращает True, если set1 является надмножеством set2
# set1 < set2, Эквивалентно set1 <= set2 and set1 != set2 (строгое подмножество)
# set1 > set2, Эквивалентно set1 >= set2 and set1 != set2 (строгое надмножество)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Множества frozenset() ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# НЕизменяемый тип данных;
# Хэшируемый;
# Содержит, только уникальные элементы.

# 1. Множества не поддерживают сортировку.
# 2. Множества не поддерживают индексирование элементов.
# 3. Двоичные операции, которые смешивают типы set с frozenset, возвращают тип первого операнда.
#    Например: frozenset('ab') | set('bc') возвращает тип frozenset.
# 4. Оба типа set и frozenset поддерживают операции сравнения. Тип set сравниваются с типом frozenset на основе
# их членов. Например:

print(set('abc') == frozenset('abc'))  # True
print(set('abc') in {frozenset('abc')})  # True

myset1 = frozenset({1, 2, 3})  # на основе множества
myset2 = frozenset([1, 1, 2, 3, 4, 4, 4, 5, 6, 6])  # на основе списка
myset3 = frozenset('aabcccddee')  # на основе строки
# frozenset({1, 2, 3})
# frozenset({1, 2, 3, 4, 5, 6})
# frozenset({'e', 'd', 'c', 'b', 'a'})

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Операции над замороженными множествами:

# объединение множеств: метод union() или оператор |;
# пересечение множеств: метод intersection() или оператор &;
# разность множеств: метод difference() или оператор -;
# симметрическая разность множеств: метод symmetric_difference() или оператор ^.

myset1 = frozenset('hello')
myset2 = frozenset('world')

print(myset1 | myset2)  # frozenset({'l', 'w', 'e', 'h', 'r', 'd', 'o'})
print(myset1 & myset2)  # frozenset({'l', 'o'})
print(myset1 ^ myset2)  # frozenset({'d', 'h', 'w', 'e', 'r'})




# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Генераторы множеств ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

squares = {i ** 2 for i in range(10)}
cubes = {i ** 3 for i in range(10, 21)}
chars = {c for c in 'abcdefg'}

print(squares, cubes, chars, sep="\n")
# {0, 1, 64, 4, 36, 9, 16, 49, 81, 25}
# {1728, 4096, 8000, 1000, 5832, 6859, 3375, 4913, 1331, 2197, 2744}
# {'g', 'e', 'f', 'a', 'd', 'c', 'b'}

digits = {int(d) for d in 'abcd12ef78ghj90' if d.isdigit()}
# {0, 1, 2, 7, 8, 9}


# С помощью генератора, итерируем массив для вывода уникальных значений в множестве.
items = [10, '30', 30, 10, '56', 34, '12', 90, 89, 34, 45, '67', 12, 10, 90, 23, '45', 56, '56', 1, 5, '6', 5]
res = {int(i) for i in items}

print(*sorted(res))  # 1 5 6 10 12 23 30 34 45 56 67 89 90

# С помощью генератора, итерируем массив для вывода уникальных значений(первых букв в словах) в множестве.
words: list[str] = [
    'Plum', 'Grapefruit', 'apple', 'orange', 'pomegranate', 'Cranberry', 'lime', 'Lemon', 'grapes',
    'persimmon', 'tangerine', 'Watermelon', 'currant', 'Almond'
]

final_array = {i[0].lower() for i in words}  # type: set[iter]

print(*sorted(final_array))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Множества в математике ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# В математике множество – совокупность объектов, понимаемых как единое целое.

# При этом предполагается, что объекты данной совокупности можно отличать друг от друга и от объектов, не входящих
# в эту совокупность. Например, можно говорить:

# 1. Множества всех языков программирования;
# 2. множества всех натуральных чисел;
# 3. множества всех точек данного отрезка.

# Языки программирования, натуральные числа, точки данного отрезка – элементы соответствующих
# множеств.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Обозначения:

# Обычно множества обозначают большими латинскими буквами: X, Y...,
# а элементы множеств – латинскими строчными буквами: x, y...,

# Запись x ∈ X (x !∈ X) означает, что x является (не является) элементом множества X.

# Элементы множества указываются в фигурных скобках.
# Рассмотрим множество вещей: {худи, кепка, футболка}. Такое множество содержит три элемента.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Конечные и бесконечные множества:

A = {'a', 'b', 'c'}  # Конечное множество;
B = {'Владислав', 'Андрей', 'Юлия'}  # Конечное множество;
C = {1, 2, 3, 4, 5, 6}  # и т.д. Бесконечное множество натуральных чисел.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Равенство множеств:

# Если два множества X и Y состоят из одних и тех же элементов, то они называются равными X = Y.
# Если в множествах, количество элементов равно и они одинаковы, даже если их порядок разный, они равны!
a = {1, 2, 3}
b = {2, 3, 1}
print(b == a)  # True

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Подмножество и надмножество:

# Если все элементы множества X принадлежат также и множеству Y, то говорят, что X является подмножеством Y,
# а записывается это так: X ⊂ Y.

X = {1, 2, 3}  # Является подмножеством Y (X ⊂ Y).
Y = {1, 2, 3, 4, 5}  # Является надмножеством X (Y ⊃ X).
# Так как все элементы множества X содержатся в множестве Y, то мы говорим, что множество X является подмножеством
# множества Y.

X1 = {1, 2, 3, 6}  # Не является подмножеством Y2.
Y2 = {1, 2, 3, 4, 5}

# Любое множество также является подмножеством самого себя. Про такое подмножество говорят нестрогое подмножество:
# множество {1, 2, 3} является нестрогим подмножеством множества {1, 2, 3};
# множество {1, 2, 3} является строгим подмножеством множества {1, 2, 3, 4}.
X3 = {'a', 'b', 'c', 'd', 'e'}
print(2 ** len(X3) - 1)  # 31 кол-во строгих подмножеств
print(2 ** len(X3))

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Пустое множество:

# Множества, которые не содержат элементов, являются пустыми подмножествами.

# Примеры пустых множеств:

# множество лошадей, пасущихся на луне;
# множество точек пересечения двух параллельных прямых на плоскости;
# множество квадратных уравнений, имеющих больше двух корней (действительных);

# Пустое множество является подмножеством любого множества.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Числовые множества ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# К основным числовым множествам математики относятся:

# 1. множество натуральных чисел;
# 2. множество целых чисел;
# 3. множество рациональных чисел;
# 4. множество вещественных чисел;
# 5. множество комплексных чисел.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Натуральные числа:

N = {1, 2, 3, 4, 5}  # и т.д.
# ! 0 - не является натуральным числом


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Целые числа:

Z = {-3, -2, -1, 0, 1, 2, 3}  # и т.д.
# ! Множество натуральных чисел является подмножеством множества целых чисел.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Рациональные числа:

Q = {0.5, 0.375, 0.3333, 0.633333}
# Конечная непериодическая или бесконечная периодическая дробь.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Иррациональные числа:

I = {1.414213562, 3.1415926535, 2.71828182845}
# Бесконечная непериодическая дробь.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Вещественные числа:

R = {0.5, 0.375, 0.3333, 0.633333, 1.414213562, 3.1415926535, 2.71828182845}


# Объединение рациональных и иррациональных чисел образует множество вещественных чисел.
# Каждому вещественному числу соответствует определённая точка числовой прямой, и наоборот – каждой точке числовой
# прямой обязательно соответствует некоторое вещественное число.

# Множество вещественных чисел также называют множеством действительных чисел.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Множество комплексных чисел:
def complex_number(r: float, r2: float) -> complex:
    i = -1 ** 0.5  # Мнимое число

    c = r + r2 * i

    return complex(c)


if __name__ == '__main__':
    print(complex_number(1.414213562, 0.3333))  # (1.080913562+0j)


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Диаграммы Эйлера-Венна ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Диаграммы Эйлера-Венна – геометрическое представление множеств. Большой прямоугольник представляет универсальное
# множество U, а круги в нем – отдельные множества. Круги пересекаются в соответствии с условиями задачи.
# Точки внутри областей диаграммы — элементы соответствующих множеств. На диаграмме можно заштриховать образованные
# при пересечении кругов множества.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Задачи ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
def online_school_students() -> str:
    """Каждый ученик онлайн-школы изучает или математику или информатику, или и то и другое одновременно.
     Всего 75 учеников изучает математику, а 27 – информатику и только 13 – оба предмета.
     Сколько учеников учится в онлайн-школе ?"""

    students_of_mathematics: list = list(range(75))
    computer_science_students: list = list(range(27))
    students_of_computer_science_and_mathematics: list = list(range(13))

    only_students_of_mathematics: list = list(
        set(students_of_mathematics).difference(students_of_computer_science_and_mathematics))

    only_computer_science_students: list = list(
        set(computer_science_students).difference(students_of_computer_science_and_mathematics))

    all_students: list = (students_of_computer_science_and_mathematics + only_students_of_mathematics
                          + only_computer_science_students)

    return f"Всего студентов в онлайн-школе: {len(all_students)} человек."


if __name__ == '__main__':
    print(online_school_students())


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


def survey_students() -> str:
    """Опрос 100 студентов дал следующие результаты по количеству изучающих разные иностранные языки:
    испанский – 28, немецкий – 30, французский – 42, испанский и немецкий – 8,
    испанский и французский – 10, немецкий и французский – 5, все три языка – 3.

    Сколько студентов не изучает ни одного языка?
    Сколько студентов изучает один французский язык?
    """

    all_students: list = list(range(100))

    spain_language: list = list(range(28))
    germany_language: list = list(range(30))
    french_language: list = list(range(42))

    spain_and_germany_language: list = list(range(8))
    spain_and_french_language: list = list(range(10))
    germany_and_french_language: list = list(range(5))

    all_language: list = list(range(3))

    only_germany_and_french: int = len(set(germany_and_french_language).difference(all_language))
    only_spain_and_french: int = len(set(spain_and_french_language).difference(all_language))
    only_spain_and_germany: int = len(set(spain_and_germany_language).difference(all_language))

    only_spain: int = len(
        set(spain_language).difference(set(all_language))) - only_spain_and_germany - only_spain_and_french
    only_germany: int = len(
        set(germany_language).difference(set(all_language))) - only_spain_and_germany - only_germany_and_french
    only_french: int = len(
        set(french_language).difference(set(all_language))) - only_germany_and_french - only_spain_and_french

    all_students_learn_lang: int = sum([only_spain, only_germany, only_french, only_germany_and_french,
                                        only_spain_and_germany, only_spain_and_french, len(all_language)])

    students_not_learn_lang: int = len(all_students) - all_students_learn_lang

    return (f"{students_not_learn_lang} студентов не изучают ни одного языка.\n"
            f"{only_french} студентов изучает только французский язык.")


if __name__ == '__main__':
    print(survey_students())


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def all_students_learn_lang() -> int:
    """
    Каждый ученик в классе изучает английский или французский язык.
    Английский язык изучает 25 человек, французский – 27,
    а оба языка – 18. Сколько учащихся в классе?
    """

    english_lang, french_lang = set(range(25)), set(range(27))

    union_lang: set = set(range(18))

    only_english: set = english_lang - union_lang
    only_french: set = french_lang - union_lang

    all_students: int = sum([len(only_english), len(only_french), len(union_lang)])

    return all_students


if __name__ == '__main__':
    print(all_students_learn_lang())


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def Timur_and_team() -> int:
    """
    n учеников школы поехали отдыхать на море,
    m учеников съездили в деревню,
    а k учеников сходили в горы.
    Оказалось, что и в деревне, и на море были x учеников, а в деревне и в горах — y учеников.
    Побывать и в горах, и на море не удалось никому.

    Напишите программу для определения количества учеников в школе, если никто не смог
    посетить все три места сразу, а z учеников писали ДВИ по математике для поступления
    в МГУ, и никуда не ездили."""

    n, m, k, x, y, z = (int(input()) for _ in range(6))

    all_students: int = ((k + n + m) - (x + y) + z)

    return all_students


if __name__ == '__main__':
    print(Timur_and_team())


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def books_to_read() -> tuple:
    """
    "n" учеников прочитали первую книгу, "m" учеников — вторую,
    "k" учеников — третью. Также известно, что "x" учеников прочли
    первую или вторую, или обе эти книги, "y" учеников — вторую или третью,
    или обе, "z" учеников — первую и третью, или хотя бы одну из этих двух
    книг. Полностью выполнили задание только "t" учеников.
    Всего в классе учится "a" учеников.

    Напишите программу, которая выводит сколько учеников:
    Прочитали только одну книгу;
    Прочитали две книги;
    Не прочитали ни одной из рекомендованных книг.
    """

    n, m, k, x, y, z, t, a = (int(input()) for _ in range(8))

    two_books = ((n + m + k) * 2) - (x + y + z) - (t * 3)
    one_book = (x + y + z) - (n + m + k) - two_books
    not_read_books = a - (one_book + two_books + t)

    return one_book, two_books, not_read_books


if __name__ == '__main__':
    for i in books_to_read():
        print(i, end="\n")


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def three_word() -> str:
    """
    На вход программе подается строка, состоящая из любого кол-ва слов.
    Верно ли, что для записи всех слов был использован один и тот же набор букв?
    """

    array_words: list = input().split()
    first_element_array: set = set(array_words[0])

    for word in array_words:
        if first_element_array == set(word):
            pass
        else:
            return "NO"

    return "YES"


if __name__ == '__main__':
    print(three_word())


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def unique_symbols() -> int:
    """
    Напишите программу для вывода общего количества уникальных
    символов во всех считанных словах без учета регистра.
    """

    word_count: int = int(input())
    array_words: list[str] = [input().upper() for _ in range(word_count)]

    res_uniq_symbols: set = set()

    for word in array_words:
        for symbol in word:
            res_uniq_symbols.add(symbol)

    return len(res_uniq_symbols)


if __name__ == '__main__':
    print(unique_symbols())


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def number_before() -> any:
    """
    На вход программе подается строка текста, содержащая числа.
    Для каждого числа выведите слово YES (в отдельной строке), если
    это число ранее встречалось в последовательности или NO, если не встречалось.
    """

    text_numbers: list = list(map(int, input().split()))
    array_len: int = len(text_numbers)

    for index in range(array_len):
        if text_numbers[:index].count(text_numbers[index]):
            print("YES")
        else:
            print("NO")


if __name__ == '__main__':
    number_before()


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def intersection_numbers() -> int:
    """
    Напишите программу, которая определяет количество чисел,
    которые есть как в первой строке, так и во второй.
    """
    array_numbers, array_numbers2 = (map(int, input().split()) for _ in range(2))  # type: map

    intersection_array: set[int] = set(array_numbers).intersection(array_numbers2)
    inter_array_len: int = len(intersection_array)

    return inter_array_len


if __name__ == '__main__':
    print(intersection_numbers())


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def first_line_numbers() -> None:
    """
    Напишите программу, которая выводит все числа в порядке возрастания,
    находящиеся в первой строке, но отсутствующие во второй.
    """
    text_num, text_num2 = list(map(int, input().split()) for _ in range(2))  # type: map

    diff_array: set = set(text_num) - set(text_num2)
    diff_array: list = sorted(list(diff_array))

    print(*diff_array)


if __name__ == '__main__':
    first_line_numbers()


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def overall_nums() -> None:
    """
    На вход программе подается натуральное число n, а затем n различных
    натуральных чисел, каждое на отдельной строке. Напишите программу, которая
    выводит все общие цифры в порядке возрастания у всех введенных чисел.
    """
    quant_line_numbers: int = int(input())
    array_numbers: list[map] = [map(int, input()) for _ in range(quant_line_numbers)]

    inter_array: set[int] = set(array_numbers[0])

    for nums in array_numbers[1:]:
        inter_array: set[int] = inter_array.intersection(set(nums))

    print(*sorted(inter_array))


if __name__ == '__main__':
    overall_nums()


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

def all_numbers() -> None:
    """
    На вход программе подаются два числа. Напишите программу, которая определяет,
    входят ли в запись первого числа все цифры, содержащиеся в записи второго
    (независимо от повтора, то есть количества цифр) числа или нет.
    """

    line_num, line_num2 = [map(str, input()) for _ in range(2)]  # type: map

    if set(line_num).issuperset(set(line_num2)):
        print("YES")
    else:
        print("NO")


if __name__ == '__main__':
    all_numbers()

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
