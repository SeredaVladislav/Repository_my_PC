# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ int (Целые числа) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Неизменяемый тип данных
# Хэшируемый
# Не итерируемый
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Целые числа поддерживают следующие операции:

# 1. Арифметические операции;
# 2. Побитовые операции;
# 3. Операции сравнения.


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
# Примеры преобразования объектов к типу int:

# Преобразование строки с записью целого числа в десятичной форме к типу int:
int(' -3 ', base=10)  # 3

# При преобразовании десятичных литералов, записанных в строки, основание можно опускать:
int(' +5 ')  # 5
int(' -15_125')  # -15125

# Преобразование типа float в тип int:
int(3.23)  # 3
int(1.)  # 1
int(3.14e-10)  # 0, т.к. число выходит за рамки целого числа в меньшую сторону.

# Восьмеричные литералы и строки с ними - в тип int:
int(0o177)  # 127
int('  0o177 ', base=8)  # 127

# Шестнадцатеричные литералы и строки с ними - в тип int:
int(0x9ff)  # 2559
int(' 0x9ff  ', base=16)  # 2559

# Двоичные литералы и строки с ними - в тип int:
int(0b101010)  # 42
int('0b101010', base=2)  # 42
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Методы int:

# Метод int.bit_length()
# Возвращает количество битов, необходимых для представления целого числа в двоичном виде, исключая знак и
# начальные нули.

n = -37
bin(n)  # '-0b100101'
n.bit_length()  # 6


# Эквивалент:
def bit_length(self):
    # двоичное представление: bin(-37) => '- 0b100101'
    s = bin(self)
    # удалить начальные нули и знак минус
    s = s.lstrip('-0b')
    # len('100101') => 6
    return len(s)
# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Метод int.bit_count()
# Добавлен в Python 3.10. Возвращает количество единиц в двоичном представлении абсолютного значения целого числа.

n = 19
bin(n)  # '0b10011'
n.bit_count()  # 3
(-n).bit_count()  # 3


# Эквивалент:
def bit_count(self):
    return bin(self).count("1")


# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Арифметические операции ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Все числовые типы, кроме сложных, поддерживают следующие операции согласно их приоритетам выполнения:

# x + y
# Результатом будет сумма чисел x и у

# x - y
# Результатом будет разница чисел x и у

# x * y
# Результатом будет произведение чисел x и у

# x / y
# Результатом будет частное чисел x и у

# x // y
# Результатом будет деление x / y с округлением результата до ближайшего целого в меньшую сторону.
# Операцию называют "целочисленным делением".
# Результирующее значение является целым числом, хотя тип результата не обязательно является int.
# Результат всегда округляется до минус бесконечности:
# 1 // 2 равно 0,
# (-1) // 2 равно -1,
# 1 // (-2) равно -1,
# (-1) // (-2) равно 0.

# x % y
# Результатом будет остаток от деления чисел x / y.

# -x
# Результатом будет отрицательное значение x.

# +x
# В результате число x останется без изменений.

# abs(x)
# Результатом будет абсолютное значение или величина x.

# int(x)
# В результате число x преобразуется в целое число int.
# В качестве аргумента допускается использовать принятые числовые литералы включающие цифры от 0 до 9 или любой
# эквивалент Юникода.
# Преобразование вещественного числа в целое число может округляться или усекаться, как в C. Для четко определенных
# преобразований используйте math.floor() и math.ceil()

# float(x)
# В результате число x преобразуется в число с плавающей точкой float.

# В качестве аргумента допускается использовать принятые числовые литералы включающие цифры от 0 до 9 или любой
# эквивалент Юникода.
# Функция также принимает строки 'nan' - не число и 'inf' - положительная или отрицательная бесконечность,
# с необязательным префиксом + или -.

# complex(real, image)
# Результатом будет комплексное число с вещественной частью real, мнимой частью image.
# В качестве аргумента допускается использовать принятые числовые литералы включающие цифры от 0 до 9 или любой
# эквивалент Юникода.

# c.conjugate()
# Результатом будет сопряженное комплексное число с.

# divmod(x, y)
# Результатом будет пара (x // y, x % y).

# pow(x, y)
# Результатом будет число x в степени у. Python определяет 0 ** 0 как равное 1, как это обычно бывает для
# языков программирования.

# x ** y
# Результатом будет число x в степени у. Python определяет pow(0, 0) как равное 1, как это обычно бывает для
# языков программирования.

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Битовые операции над целыми числами ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

# Побитовые операции:

# x << y - побитовый сдвиг влево
# x >> y - побитовый сдвиг вправо
# x & y - побитовое И
# x ^ y - побитовое исключающее ИЛИ
# x | y - побитовое ИЛИ
# ~x - побитовое НЕ


# Примеры использования:
x = 5
y = 6
print(x & y)  # 4
print(x | y)  # 7
print(x ^ y)  # 3
print(~x)  # -6
x = 5
print(x << 2)  # 20
print(x >> 2)  # 1

# ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Битовые операции над целыми числами ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


# Разрешенные операции сравнения:

# x < y - строго x меньше y,
# x <= y - x меньше или равно y,
# x > y - строго x больше y,
# x >= y - x больше или равно y,
# x == y - x равно y,
# x != y - x не равно y.

# Внимание! Комплексные числа (тип complex) не поддерживают сравнение порядка.

# Сравнения могут быть связаны произвольно и записаны в цепочки сравнений, в которых для соединения сравнений
# используются неявные логические операторы and.

# x < y <= z
# эквивалентно
# x < y and y <= z
# В примере выше y вычисляется только один раз. Если x < y оказывается ложным, то в обоих случаях, приведенных выше
# z не оценивается вообще.

# Еще пример:
# a < b <= c < d
# # эквивалентно
# a < b and b <= c and c < d
# В такой форме сравнения легче читаются, и каждое подвыражение вычисляется по крайней мере один раз.

# Объекты разных типов, за исключением различных числовых типов, никогда не будут равными.

# Оператор == всегда определен, но для некоторых типов объектов, например объектов класса, эквивалентен
# оператору идентичности is.

# Операторы <, <=, > и >= применяются только там, где они имеют смысл, например они вызывают исключение
# TypeError, когда один из аргументов является комплексным числом.
